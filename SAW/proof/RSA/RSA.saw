// TODO: Copyright notice
// TODO: Split into multiple files

enable_experimental;

m <- llvm_load_module "../../build/llvm/crypto/crypto_test.bc";

include "../common/helpers.saw";

let EVP_PKEY_OP_ENCRYPT = 64;
let RSA_NO_PADDING = 3;
//let RSA_PKEY_CTX_SIZE = eval_int {{ (4 + 8 + 4 + 8 + 8 + 4 + 8 + 8 + 8) : [64] }};
//let RSA_PKEY_CTX_SIZE = eval_int {{ (8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8) : [64] }};
// RSA_PKEY_CTX is a mix of 9 ints and pointers.  However, no two ints appear
// consecutively in the struct, so the compiler must pad them out with an extra
// 32 bits on the end.  This combined with little-endian encoding means we can
// abstract over the struct as an array of 9 64-bit integers.
let RSA_PKEY_CTX_WORDS = 9;
let PAD_MODE_IDX = 2;

let points_to_bignum_st ptr d_ptr dmax = do {
  crucible_points_to (crucible_field ptr "d") d_ptr;
  crucible_points_to (crucible_field ptr "width") (crucible_term {{ `dmax : [32] }});
  crucible_points_to (crucible_field ptr "dmax") (crucible_term {{ `dmax : [32] }});
  crucible_points_to (crucible_field ptr "neg") (crucible_term {{ 0 : [32] }});
  crucible_points_to (crucible_field ptr "flags") (crucible_term {{ 0 : [32] }});
};


// TODO: Re-enable asserts on montgomery_inv.c:120 and 160 (disabled because SAW is slow
// to reason about it)

// TODO: Put this in a common file with the SHA memory specs?
let OPENSSL_malloc_sym_spec = do {
  size <- crucible_fresh_var "size" i64;
  crucible_execute_func [crucible_term size];
  ptr <- crucible_symbolic_alloc false 16 size;
  crucible_return ptr;
};

let OPENSSL_malloc_spec size = do {
  crucible_execute_func [crucible_term {{ `size : [64] }}];
  ptr <- crucible_alloc_aligned 128 (llvm_array size (llvm_int 8));
  crucible_return ptr;
};

let OPENSSL_free_nonnull_spec size = do {
  ptr <- crucible_alloc (llvm_array size (llvm_int 8));
  crucible_execute_func [ptr];
};

let OPENSSL_realloc_null_spec new_size = do {
  crucible_execute_func [crucible_null, crucible_term {{ `new_size : [64] }}];
  ptr <- crucible_alloc_aligned 128 (llvm_array new_size (llvm_int 8));
  crucible_return ptr;
};

let OPENSSL_realloc_nonnull_spec old_size new_size = do {
  old_ptr <- crucible_alloc (llvm_array old_size (llvm_int 8));
  crucible_execute_func [ old_ptr, crucible_term {{ `new_size : [64] }} ];
  new_ptr <- crucible_alloc_aligned 128 (llvm_array new_size (llvm_int 8));
  crucible_return new_ptr;
};


let OPENSSL_free_null_spec = do {
  crucible_execute_func [crucible_null];
};

let CRYPTO_MUTEX_lock_spec = do {
  lock_ptr <- crucible_alloc (llvm_struct "union.crypto_mutex_st");
  crucible_execute_func [lock_ptr];
};

let BN_num_bytes_n_spec modulus_words = do {
  n_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  (n_d, n_d_ptr) <- ptr_to_fresh_readonly "n_d" (llvm_array modulus_words i64);
  points_to_bignum_st n_ptr n_d_ptr modulus_words;
  // `n_d` must have a nonzero value in byte (modulus_bytes - 1) to be considered
  // `modulus_bytes` long.
  // TODO: Handle case where modulus_bytes is not a multiple of 8
  crucible_precond {{ (n_d ! 0) >= (2^^56) }};
  // `n_d` must be odd
  // TODO: I think this somehow breaks when OPENSSL_PUT_ERROR is properly
  // defined?
  crucible_precond {{ ((n_d @ 0) && 1) == 1 }};
  crucible_execute_func [n_ptr];
  crucible_return (crucible_term {{ (`modulus_words * 8) : [32] }});
};

let bn_minimal_width_n_spec modulus_words = do {
  n_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  (n_d, n_d_ptr) <- ptr_to_fresh_readonly "n_d" (llvm_array modulus_words i64);
  points_to_bignum_st n_ptr n_d_ptr modulus_words;
  // `n_d` must have a nonzero value in byte (modulus_bytes - 1) to be considered
  // `modulus_bytes` long.
  // TODO: Handle case where modulus_bytes is not a multiple of 8
  crucible_precond {{ (n_d ! 0) >= (2^^56) }};
  // `n_d` must be odd
  // TODO: I think this somehow breaks when OPENSSL_PUT_ERROR is properly
  // defined?
  crucible_precond {{ ((n_d @ 0) && 1) == 1 }};
  crucible_execute_func [n_ptr];
  crucible_return (crucible_term {{ `modulus_words : [32] }});
};

let bn_mont_n0_spec = do {
  n_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  crucible_execute_func [n_ptr];
  ret <- crucible_fresh_var "ret" i64;
  crucible_return (crucible_term ret);
};

bn_mont_n0_ov <- crucible_llvm_unsafe_assume_spec
  m
  "bn_mont_n0"
  (bn_mont_n0_spec);

bn_minimal_width_n_ov <- crucible_llvm_unsafe_assume_spec
  m
  "bn_minimal_width"
  (bn_minimal_width_n_spec 8);

BN_num_bytes_n_ov <- crucible_llvm_unsafe_assume_spec
  m
  "BN_num_bytes"
  (BN_num_bytes_n_spec 8);

OPENSSL_realloc_nonnull_ov <- crucible_llvm_unsafe_assume_spec
  m
  "OPENSSL_realloc"
  // TODO: I'm not sure 32 is even the right old_size.  It surprisingly doesn't
  // seem to matter?  But the symbolic version doesn't work at all.  I guess it
  // works because the C only knows it's an i8*, but doesn't know how big the
  // underlying memory is
  (OPENSSL_realloc_nonnull_spec 32 64);

OPENSSL_realloc_null_ov <- crucible_llvm_unsafe_assume_spec
  m
  "OPENSSL_realloc"
  (OPENSSL_realloc_null_spec 256);

OPENSSL_free_null_ov <- crucible_llvm_unsafe_assume_spec
  m
  "OPENSSL_free"
  OPENSSL_free_null_spec;

CRYPTO_MUTEX_lock_read_ov <- crucible_llvm_unsafe_assume_spec
  m
  "CRYPTO_MUTEX_lock_read"
  CRYPTO_MUTEX_lock_spec;

CRYPTO_MUTEX_unlock_read_ov <- crucible_llvm_unsafe_assume_spec
  m
  "CRYPTO_MUTEX_unlock_read"
  CRYPTO_MUTEX_lock_spec;

CRYPTO_MUTEX_lock_write_ov <- crucible_llvm_unsafe_assume_spec
  m
  "CRYPTO_MUTEX_lock_write"
  CRYPTO_MUTEX_lock_spec;

CRYPTO_MUTEX_unlock_write_ov <- crucible_llvm_unsafe_assume_spec
  m
  "CRYPTO_MUTEX_unlock_write"
  CRYPTO_MUTEX_lock_spec;


// Assume `OPENSSL_malloc` satisfies `OPENSSL_malloc_spec`
// TODO: I think the 48 byte malloc applies to rsa_impl.c:284 but it's not
// clear to me why rsa_size would have to be 48 bytes.  It seems like it could
// be any value between 0 and the modulus size in bytes (64 with the current
// setting).
/*
OPENSSL_malloc_ov_48 <- crucible_llvm_unsafe_assume_spec
  m
  "OPENSSL_malloc"
  (OPENSSL_malloc_spec 48);
// TODO: Where do these mallocs come from?
OPENSSL_malloc_ov_256 <- crucible_llvm_unsafe_assume_spec
  m
  "OPENSSL_malloc"
  (OPENSSL_malloc_spec 256);
OPENSSL_malloc_ov_40 <- crucible_llvm_unsafe_assume_spec
  m
  "OPENSSL_malloc"
  (OPENSSL_malloc_spec 40);
  */

/*
malloc_nums <- for (eval_list {{ [0 .. 256 : [64]] }})
  (\x -> (return (eval_int x)) : (TopLevel Int));
  */

// TODO: Where are all of these allocs comming from?  Run with --sim-verbose=3
// for stack traces on them and double check they're sensible.
let malloc_nums = [24, 32, 40, 48, 256];

OPENSSL_malloc_ovs <- for malloc_nums
  (\x -> crucible_llvm_unsafe_assume_spec m "OPENSSL_malloc" (OPENSSL_malloc_spec x));

OPENSSL_malloc_sym_ov <- crucible_llvm_unsafe_assume_spec
  m
  "OPENSSL_malloc"
  OPENSSL_malloc_sym_spec;

// TODO: Remove the 24 once you get the first thing to free here
let free_nums = [24];
OPENSSL_free_nonnull_ovs <- for free_nums
  (\x -> crucible_llvm_unsafe_assume_spec m
         "OPENSSL_free"
         (OPENSSL_free_nonnull_spec x));

// value_barrier_w just returns its input (it exists to prevent the compiler
// from unding constant-time code)
let value_barrier_w_spec = do {
  a <- crucible_fresh_var "a" i64;
  crucible_execute_func [(crucible_term a)];
  crucible_return (crucible_term a);
};

value_barrier_w_ov <- crucible_llvm_unsafe_assume_spec
  m
  "value_barrier_w"
  value_barrier_w_spec;

let points_to_evp_pkey_ctx_st ptr pmeth_ptr pkey_ptr operation data_ptr = do {
  crucible_points_to (crucible_field ptr "pmeth") pmeth_ptr;
  crucible_points_to (crucible_field ptr "pkey") pkey_ptr;
  crucible_points_to (crucible_field ptr "operation")
                     (crucible_term {{ `operation : [32] }});
  crucible_points_to (crucible_field ptr "data") data_ptr;
};

let points_to_evp_pkey_method_st ptr = do {
  crucible_points_to (crucible_field ptr "encrypt")
                     (crucible_global "pkey_rsa_encrypt");
};

let points_to_evp_pkey_st ptr rsa_ptr = do {
  crucible_points_to (crucible_field ptr "pkey") rsa_ptr;
  crucible_points_to (crucible_field ptr "ameth")
                     (crucible_global "rsa_asn1_meth");
};

// TODO: This implements the default RSA_METHOD, which is all NULL.  Do we want
// to support non-default RSA_METHOD structs?
let points_to_rsa_meth_st ptr = do {
  crucible_points_to (crucible_field ptr "size") crucible_null;
};

let points_to_rsa_st ptr meth_ptr n_ptr e_ptr = do {
  crucible_points_to (crucible_field ptr "meth") meth_ptr;
  crucible_points_to (crucible_field ptr "n") n_ptr;
  crucible_points_to (crucible_field ptr "e") e_ptr;
  // TODO: Should this field be null?  mont_n is a cache, and setting it to
  // forces the encrypt function to initialize the cache, which seems right
  // here.  Is there a reason it wouldn't be null?
  crucible_points_to (crucible_field ptr "mont_n") crucible_null;
};
/*
let BN_div_spec numerator_dmax divisor_dmax = do {
  //rem_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  //points_to_bignum_st rem_ptr crucible_null 0;
  //numerator_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  //(numerator, numerator_d_ptr) <- ptr_to_fresh_readonly "numerator" (llvm_array numerator_dmax i64);
  numerator_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  (numerator, numerator_d_ptr) <- ptr_to_fresh "numerator" (llvm_array numerator_dmax i64);
  points_to_bignum_st numerator_ptr numerator_d_ptr numerator_dmax;
  divisor_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  (divisor, divisor_d_ptr) <- ptr_to_fresh_readonly "divisor" (llvm_array divisor_dmax i64);
  points_to_bignum_st divisor_ptr divisor_d_ptr divisor_dmax;
  ctx_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_ctx");
  crucible_execute_func
    [ crucible_null // quotient_ptr
    , numerator_ptr // rem_ptr
    , numerator_ptr
    , divisor_ptr
    , ctx_ptr
    ];

  let rem_ptr = numerator_ptr;
  rem_d_ptr <- crucible_alloc (llvm_array divisor_dmax i64);
  crucible_points_to rem_d_ptr (crucible_term {{ take`{divisor_dmax} (reverse (split`{each=64} ((join (reverse numerator)) % (0 # (join (reverse divisor)))))) }});
  points_to_bignum_st rem_ptr rem_d_ptr divisor_dmax;
  crucible_return (crucible_term {{ 1 : [32] }});
};

BN_div_ov <- crucible_llvm_unsafe_assume_spec
  m
  "BN_div"
  (BN_div_spec 13 8);  // TODO: Where did these values come from?
  */

let BN_div_spec divisor_dmax = do {
  //rem_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  //points_to_bignum_st rem_ptr crucible_null 0;
  //numerator_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  //(numerator, numerator_d_ptr) <- ptr_to_fresh_readonly "numerator" (llvm_array numerator_dmax i64);
  numerator_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  divisor_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  ctx_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_ctx");
  crucible_execute_func
    [ crucible_null // quotient_ptr
    , numerator_ptr // rem_ptr
    , numerator_ptr
    , divisor_ptr
    , ctx_ptr
    ];

  let rem_ptr = numerator_ptr;
  rem_d_ptr <- crucible_alloc (llvm_array divisor_dmax i64);
  points_to_bignum_st rem_ptr rem_d_ptr divisor_dmax;
  crucible_return (crucible_term {{ 1 : [32] }});
};

BN_div_ov <- crucible_llvm_unsafe_assume_spec
  m
  "BN_div"
  (BN_div_spec 8);  // TODO: Where did these values come from?

let points_to_rsa_pkey_ctx ptr = do {
  // `pad_mode` is technically a 32 bit integer, but the compiler must pad the
  // space to 64 bits as the following element in the struct is a pointer.
  // We can treat this int like a 64-bit value as little-endian encoding
  // ensures the low order bytes end up at the lower address and fit in the 32
  // bits dedicated to the `pad_mode` field.
  crucible_points_to (crucible_elem ptr PAD_MODE_IDX)
                     (crucible_term {{ `RSA_NO_PADDING : [64] }});
};

/*
let EVP_PKEY_init = do {
  pkey <- crucible_alloc 
}
*/

/*
let rsa_st_init = do {

}
*/

// TODO: Verify this still works after reverting change to OPENSSL_PUT_ERROR
// (Initially changed because it requires some pthread functions and is
// orthogonal to what we want to prove).
// Potential problems:
//  * p_rsa.c:318: rsa->n might be underconstrained and trigger this
//    OPENSSL_PUT_ERROR.  Just need to properly set n to fix this.
// TODO: out_len must be >= modulus_bytes
let EVP_PKEY_encrypt_spec out_len in_len modulus_bytes = do {
  // TODO: Do I have to initialize this global?
  //crucible_alloc_global "g_thread_local_init_once";
  
  ctx_ptr <- crucible_alloc (llvm_struct "struct.evp_pkey_ctx_st");
  pmeth_ptr <- crucible_alloc (llvm_struct "struct.evp_pkey_method_st");
  points_to_evp_pkey_method_st pmeth_ptr;
  pkey_ptr <- crucible_alloc (llvm_struct "struct.evp_pkey_st");
  rsa_ptr <- crucible_alloc (llvm_struct "struct.rsa_st");
  meth_ptr <- crucible_alloc (llvm_struct "struct.rsa_meth_st");
  points_to_rsa_meth_st meth_ptr;
  n_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  let modulus_words = eval_int {{ ((`modulus_bytes + 7) / 8) : [64]}};
  (n_d, n_d_ptr) <- ptr_to_fresh "n_d" (llvm_array modulus_words i64);
  points_to_bignum_st n_ptr n_d_ptr modulus_words;
  // `n_d` must have a nonzero value in byte (modulus_bytes - 1) to be considered
  // `modulus_bytes` long.
  // TODO: Handle case where modulus_bytes is not a multiple of 8
  crucible_precond {{ (n_d ! 0) >= (2^^56) }};
  // `n_d` must be odd
  // TODO: I think this somehow breaks when OPENSSL_PUT_ERROR is properly
  // defined?
  crucible_precond {{ ((n_d @ 0) && 1) == 1 }};
  //crucible_precond {{ ((split`{each=8} (join n_d)) @ (`modulus_bytes - 1)) > 0 }};
  // TODO: If `modulus_bytes` is not a multiple of the word
  // size (8), then `n_d` must have all bytes above `modulus_bytes` zeroed
  // out.
  e_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  (e_d, e_d_ptr) <- ptr_to_fresh "e_d" i64;
  // e_d must be 33 bits or fewer wide
  crucible_precond {{ e_d <= (2 ^^ 33 - 1) }};
  points_to_bignum_st e_ptr e_d_ptr 1;
  points_to_rsa_st rsa_ptr meth_ptr n_ptr e_ptr;
  points_to_evp_pkey_st pkey_ptr rsa_ptr;
  // TODO: data_ptr actully points to an RSA_PKEY_CTX struct.  Be *very
  // careful* with getting the contents of this right.
  data_ptr <- crucible_alloc (llvm_array RSA_PKEY_CTX_WORDS i64);
  points_to_rsa_pkey_ctx data_ptr;
  points_to_evp_pkey_ctx_st ctx_ptr pmeth_ptr pkey_ptr EVP_PKEY_OP_ENCRYPT data_ptr;

  out_ptr <- crucible_alloc (llvm_array out_len i8);

  out_len_ptr <- crucible_alloc i64;
  crucible_points_to out_len_ptr (crucible_term {{ `out_len : [64] }});

  (input, in_ptr) <- ptr_to_fresh_readonly "input" (llvm_array in_len i8);

  // TODO: Fill these params in properly
  crucible_execute_func
    [ ctx_ptr
    , out_ptr
    , out_len_ptr
    , in_ptr
    , crucible_term {{ `in_len : [64] }}
    ];

  crucible_return (crucible_term {{ 1 : [32] }});
};

crucible_llvm_verify m "EVP_PKEY_encrypt"
  (concat
   OPENSSL_free_nonnull_ovs
   (concat
    OPENSSL_malloc_ovs
    [value_barrier_w_ov,
     OPENSSL_free_null_ov,
     OPENSSL_malloc_sym_ov,
     CRYPTO_MUTEX_lock_read_ov,
     CRYPTO_MUTEX_unlock_read_ov,
     CRYPTO_MUTEX_lock_write_ov,
     CRYPTO_MUTEX_unlock_write_ov,
     OPENSSL_realloc_null_ov,
     OPENSSL_realloc_nonnull_ov//,
     //BN_div_ov,
     //bn_mont_n0_ov,
     //bn_minimal_width_n_ov,
     /*BN_num_bytes_n_ov*/]))
  //(concat [value_barrier_w_ov] OPENSSL_malloc_ovs)
  true
  (EVP_PKEY_encrypt_spec 64 64 64)
  do {
    //(simplify basic_ss);
    //(print_goal);
    (w4_unint_yices []);
  };
