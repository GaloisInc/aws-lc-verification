// TODO: Copyright notice
// TODO: Split into multiple files

enable_experimental;

m <- llvm_load_module "../../build/llvm/crypto/crypto_test.bc";

//include "../common/helpers.saw";
include "../SHA256/SHA256.saw";

let EVP_PKEY_OP_ENCRYPT = 64;
let EVP_PKEY_OP_DECRYPT = 128;
let RSA_PKCS1_PADDING = 1;
let RSA_NO_PADDING = 3;
let RSA_PKCS1_OAEP_PADDING = 4;
//let RSA_PKEY_CTX_SIZE = eval_int {{ (4 + 8 + 4 + 8 + 8 + 4 + 8 + 8 + 8) : [64] }};
//let RSA_PKEY_CTX_SIZE = eval_int {{ (8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8) : [64] }};
// RSA_PKEY_CTX is a mix of 9 ints and pointers.  However, no two ints appear
// consecutively in the struct, so the compiler must pad them out with an extra
// 32 bits on the end.  This combined with little-endian encoding means we can
// abstract over the struct as an array of 9 64-bit integers.
let RSA_PKEY_CTX_WORDS = 9;
let PAD_MODE_IDX = 2;
let MD_IDX = 3;
let MGF1MD_IDX = 4;
let TBUF_IDX = 6;
let OAEP_LABEL_IDX = 7;
let OAEP_LABELLEN_IDX = 8;
let BN_CTX_START_FRAMES = 32;

// BN stack offsets
let BN_STACK_INDEXES_IDX = 0;
let BN_STACK_DEPTH_IDX = 1;

let RSA_FLAG_NO_BLINDING = 8;

let points_to_bignum_st ptr d_ptr dmax = do {
  crucible_points_to (crucible_field ptr "d") d_ptr;
  crucible_points_to (crucible_field ptr "width") (crucible_term {{ `dmax : [32] }});
  crucible_points_to (crucible_field ptr "dmax") (crucible_term {{ `dmax : [32] }});
  crucible_points_to (crucible_field ptr "neg") (crucible_term {{ 0 : [32] }});
  crucible_points_to (crucible_field ptr "flags") (crucible_term {{ 0 : [32] }});
};


// TODO: Re-enable asserts on montgomery_inv.c:120 and 160 (disabled because SAW is slow
// to reason about it)

// TODO: Put this in a common file with the SHA memory specs?
let OPENSSL_malloc_sym_spec = do {
  size <- crucible_fresh_var "size" i64;
  crucible_execute_func [crucible_term size];
  ptr <- crucible_symbolic_alloc false 16 size;
  crucible_return ptr;
};

let OPENSSL_malloc_spec size = do {
  crucible_execute_func [crucible_term {{ `size : [64] }}];
  ptr <- crucible_alloc_aligned 128 (llvm_array size (llvm_int 8));
  crucible_return ptr;
};

let OPENSSL_free_nonnull_spec size = do {
  ptr <- crucible_alloc (llvm_array size (llvm_int 8));
  crucible_execute_func [ptr];
};

let OPENSSL_realloc_null_spec new_size = do {
  crucible_execute_func [crucible_null, crucible_term {{ `new_size : [64] }}];
  ptr <- crucible_alloc_aligned 128 (llvm_array new_size (llvm_int 8));
  crucible_return ptr;
};

let OPENSSL_realloc_nonnull_spec old_size new_size = do {
  old_ptr <- crucible_alloc (llvm_array old_size (llvm_int 8));
  crucible_execute_func [ old_ptr, crucible_term {{ `new_size : [64] }} ];
  new_ptr <- crucible_alloc_aligned 128 (llvm_array new_size (llvm_int 8));
  crucible_return new_ptr;
};

let OPENSSL_cleanse_spec len = do {
  ptr <- crucible_alloc (llvm_array len (llvm_int 8));
  crucible_execute_func [ptr, crucible_term {{ `len : [64] }}];
  crucible_points_to ptr (crucible_term {{ zero : [len][8] }});
};

OPENSSL_cleanse_ov <- crucible_llvm_unsafe_assume_spec
  m
  "OPENSSL_cleanse"
  (OPENSSL_cleanse_spec SHA256_CTX_SIZE);

let OPENSSL_free_null_spec = do {
  crucible_execute_func [crucible_null];
};

let CRYPTO_MUTEX_lock_spec = do {
  lock_ptr <- crucible_alloc (llvm_struct "union.crypto_mutex_st");
  crucible_execute_func [lock_ptr];
};

let BN_num_bytes_n_spec modulus_words = do {
  n_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  (n_d, n_d_ptr) <- ptr_to_fresh_readonly "n_d" (llvm_array modulus_words i64);
  points_to_bignum_st n_ptr n_d_ptr modulus_words;
  // `n_d` must have a nonzero value in byte (modulus_bytes - 1) to be considered
  // `modulus_bytes` long.
  // TODO: Handle case where modulus_bytes is not a multiple of 8
  crucible_precond {{ (n_d ! 0) >= (2^^56) }};
  // `n_d` must be odd
  // TODO: I think this somehow breaks when OPENSSL_PUT_ERROR is properly
  // defined?
  crucible_precond {{ ((n_d @ 0) && 1) == 1 }};
  crucible_execute_func [n_ptr];
  crucible_return (crucible_term {{ (`modulus_words * 8) : [32] }});
};

let bn_minimal_width_n_spec modulus_words = do {
  n_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  (n_d, n_d_ptr) <- ptr_to_fresh_readonly "n_d" (llvm_array modulus_words i64);
  points_to_bignum_st n_ptr n_d_ptr modulus_words;
  // `n_d` must have a nonzero value in byte (modulus_bytes - 1) to be considered
  // `modulus_bytes` long.
  // TODO: Handle case where modulus_bytes is not a multiple of 8
  crucible_precond {{ (n_d ! 0) >= (2^^56) }};
  // `n_d` must be odd
  // TODO: I think this somehow breaks when OPENSSL_PUT_ERROR is properly
  // defined?
  crucible_precond {{ ((n_d @ 0) && 1) == 1 }};
  crucible_execute_func [n_ptr];
  crucible_return (crucible_term {{ `modulus_words : [32] }});
};

let bn_mont_n0_spec = do {
  n_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  crucible_execute_func [n_ptr];
  ret <- crucible_fresh_var "ret" i64;
  crucible_return (crucible_term ret);
};

let CRYPTO_get_fork_generation_spec = do {
  crucible_execute_func [];
  ret <- crucible_fresh_var "ret" i64;
  crucible_return (crucible_term ret);
};

CRYPTO_get_fork_generation_ov <- crucible_llvm_unsafe_assume_spec
  m
  "CRYPTO_get_fork_generation"
  (CRYPTO_get_fork_generation_spec);

/*
let points_to_bn_mont_ctx_st ptr N = do {
  crucible_points_to (crucible_field ptr "N") (crucible_term N);
};
*/

let points_to_bignum_ctx ptr = do {
  crucible_points_to (crucible_field ptr "error") (crucible_term {{ 0 : [8] }});
};

let points_to_BN_STACK ptr indexes_ptr = do {
  crucible_points_to (crucible_elem ptr BN_STACK_INDEXES_IDX) indexes_ptr;
  crucible_points_to (crucible_elem ptr BN_STACK_DEPTH_IDX) (crucible_term {{ 1 : [64] }});
};


let wrap_BN_mod_exp_mont_spec r_words = do {
  r_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  a_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  p_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  //(m, m_ptr) <- ptr_to_fresh "m" (llvm_struct "struct.bignum_st");
  // TODO: Technically ctx_ptr is not a const input to BN_mod_exp_mont_spec.
  // However, ctx_ptr is pretty much just a stack of bignums to use as temp
  // values, and BN_mod_exp_mont_spec pops off values that it pushes to the
  // stack, so from the algorithm's perspective, the stack is unchanged.  In
  // reality though, it's possible for BN_mod_exp_mont_spec to push enough to
  // realloc the stack (though I'm not sure whether this happens), and more
  // importantly, popping the stack does not zero it, so the memory itself will
  // be different for values beyond the tip of the stack.
  ctx_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_ctx");
  /*
  points_to_bignum_ctx ctx_ptr;
  (indexes, indexes_ptr) <- ptr_to_fresh "indexes" (llvm_array 64 i64);
  crucible_precond {{ (indexes @ 0) == 0 }};
  points_to_BN_STACK (crucible_field ctx_ptr "stack") indexes_ptr;
  */
  mont_ptr <- crucible_alloc (llvm_struct "struct.bn_mont_ctx_st");
  let m_ptr = crucible_field mont_ptr "N";
  //points_to_bn_mont_ctx_st mont_ptr m;
  crucible_execute_func [r_ptr, a_ptr, p_ptr, mont_ptr, ctx_ptr, m_ptr];
  //r_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  (r_d, r_d_ptr) <- ptr_to_fresh "r_d" (llvm_array r_words i64);
  points_to_bignum_st r_ptr r_d_ptr r_words;

  // TODO: These ctx postconditions should be in the precondition too
  /*
  points_to_bignum_ctx ctx_ptr;
  crucible_postcond {{ (indexes @ 0) == 0 }};
  points_to_BN_STACK (crucible_field ctx_ptr "stack") indexes_ptr;
  */
  crucible_return (crucible_term {{ 1 : [32] }});
};

let BN_bn2bin_padded_same_size_spec words = do {
  let bytes = eval_int {{ (`words * 8) : [64] }};
  out_ptr <- crucible_alloc (llvm_array bytes i8);

  in_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  (in_d, in_d_ptr) <- ptr_to_fresh_readonly "in_d" (llvm_array words i64);
  points_to_bignum_st in_ptr in_d_ptr words;

  crucible_execute_func [out_ptr, crucible_term {{ `bytes : [64] }}, in_ptr];

  crucible_points_to out_ptr (crucible_term {{ split`{each=8} (join (reverse in_d)) }});
  crucible_return (crucible_term {{ 1 : [32] }});
};

let BN_mod_exp_mont_consttime_spec r_words = do {
  r_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  a_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  p_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  m_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  // TODO: Technically ctx_ptr is not a const input to BN_mod_exp_mont_spec.
  // However, ctx_ptr is pretty much just a stack of bignums to use as temp
  // values, and BN_mod_exp_mont_spec pops off values that it pushes to the
  // stack, so from the algorithm's perspective, the stack is unchanged.  In
  // reality though, it's possible for BN_mod_exp_mont_spec to push enough to
  // realloc the stack (though I'm not sure whether this happens), and more
  // importantly, popping the stack does not zero it, so the memory itself will
  // be different for values beyond the tip of the stack.
  ctx_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_ctx");
  mont_ptr <- crucible_alloc_readonly (llvm_struct "struct.bn_mont_ctx_st");
  crucible_execute_func [r_ptr, a_ptr, p_ptr, m_ptr, ctx_ptr, mont_ptr];
  //r_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  (r_d, r_d_ptr) <- ptr_to_fresh "r_d" (llvm_array r_words i64);
  points_to_bignum_st r_ptr r_d_ptr r_words;

  // TODO: These ctx postconditions should be in the precondition too
  /*
  points_to_bignum_ctx ctx_ptr;
  crucible_postcond {{ (indexes @ 0) == 0 }};
  points_to_BN_STACK (crucible_field ctx_ptr "stack") indexes_ptr;
  */
  crucible_return (crucible_term {{ 1 : [32] }});
};

let mod_exp_spec r0_words = do {
  r0_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  I_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");

  // *rsa is not marked const in mod_exp, but in this instance it's not
  // modified.  The only part of mod_exp that could mutate *rsa is
  // freeze_private_key, but rsa_default_private_transform already calls
  // freeze_private_key before mod_exp, so the subsequent freeze_private_key
  // call has no effect, meaning *rsa is unmodified.
  rsa_ptr <- crucible_alloc_readonly (llvm_struct "struct.rsa_st");

  ctx_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_ctx");
  crucible_execute_func [r0_ptr, I_ptr, rsa_ptr, ctx_ptr];
  (r0_d, r0_d_ptr) <- ptr_to_fresh "r0_d" (llvm_array r0_words i64);
  points_to_bignum_st r0_ptr r0_d_ptr r0_words;
  crucible_return (crucible_term {{ 1 : [32] }});
};

mod_exp_ov <- crucible_llvm_unsafe_assume_spec
  m
  "mod_exp"
  (mod_exp_spec 16);

let bn_neg_inv_mod_r_u64_spec = do {
  n <- crucible_fresh_var "n" i64;
  crucible_execute_func [crucible_term n];
  ret <- crucible_fresh_var "ret" i64;
  crucible_return (crucible_term ret);
};

// TODO: The RAND_bytes override might make this one unnecessary
let rand_nonzero_spec size = do {
  out_ptr <- crucible_alloc (llvm_array size i8);
  crucible_execute_func [out_ptr, crucible_term {{ `size : [64] }}];

  // TODO: Specify that all elements of `out` are nonzero?
  out <- crucible_fresh_var "out" (llvm_array size i8);
  crucible_points_to out_ptr (crucible_term out);

  // rand_nonzero always returns 1 because RAND_bytes always returns 1
  crucible_return (crucible_term {{ 1 : [32] }});
};

let RAND_bytes_spec size = do {
  out_ptr <- crucible_alloc (llvm_array size i8);
  crucible_execute_func [out_ptr, crucible_term {{ `size : [64] }}];

  out <- crucible_fresh_var "out" (llvm_array size i8);
  crucible_points_to out_ptr (crucible_term out);

  // RAND_bytes always returns 1
  crucible_return (crucible_term {{ 1 : [32] }});
};

let points_to_bn_blinding_st ptr Ai_ptr = do {
  crucible_points_to (crucible_field ptr "Ai") Ai_ptr;
};

// TODO: I overrode this for two reasons:
// 1. It has an annoying random within a range for bignums call, which I would
// have tried to override, if it weren't for:
// 2. It can probabilistically fail!  If it randomly picks values that aren't
// invertible it will fail.  In theory SAW should find this counterexample.  In
// practice, this is equivalent to factoring mont->N, so I bet SAW will just
// hang, but I haven't tried it.  The function calls into bn_blinding_update,
// which does a whole sequence of operations.  I'm not sure which one(s) fail
// in the failure case, but there may be a way to override just that function
// to say it returns 1?  In any case, that will almost certainly require
// knowing p and q, but a whole path through the decrypt function doesn't have
// those factors, so I'm not sure it's even worth investigating that fix.
//
// At the end of the day, the postcondition for the decrypt w/ blinding proof
// will be that if decrypt function returns 1, then the output vector is
// correct.
let BN_BLINDING_convert_spec words = do {
  n_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  b_ptr <- crucible_alloc (llvm_struct "struct.bn_blinding_st");
  e_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  mont_ptr <- crucible_alloc_readonly (llvm_struct "struct.bn_mont_ctx_st");
  ctx_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_ctx");

  crucible_execute_func [n_ptr, b_ptr, e_ptr, mont_ptr, ctx_ptr];

  // TODO: I almost certainly need to say something about n_ptr and b_ptr here
  // TODO: Look at the comment on blinding.c:203.  Does this mean n is
  // unchanged by the exit of the function?

  (n_d, n_d_ptr) <- ptr_to_fresh "n_d" (llvm_array words i64);
  points_to_bignum_st n_ptr n_d_ptr words;

  Ai_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  points_to_bn_blinding_st b_ptr Ai_ptr;

  crucible_return (crucible_term {{ 1 : [32] }});
};

let BN_mod_mul_montgomery_spec r_words = do {
  r_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");

  b_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");

  mont_ptr <- crucible_alloc_readonly (llvm_struct "struct.bn_mont_ctx_st");
  ctx_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_ctx");

  crucible_execute_func [r_ptr, r_ptr, b_ptr, mont_ptr, ctx_ptr];

  // Get the sizes right to avoid padding
  (r_d, r_d_ptr) <- ptr_to_fresh "r_d" (llvm_array r_words i64);
  points_to_bignum_st r_ptr r_d_ptr r_words;

  crucible_return (crucible_term {{ 1 : [32] }});
};

let BN_mod_mul_montgomery_nonoverlap_spec r_words = do {
  r_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");

  a_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  b_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");

  mont_ptr <- crucible_alloc_readonly (llvm_struct "struct.bn_mont_ctx_st");
  ctx_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_ctx");

  crucible_execute_func [r_ptr, a_ptr, b_ptr, mont_ptr, ctx_ptr];

  // Get the sizes right to avoid padding
  (r_d, r_d_ptr) <- ptr_to_fresh "r_d" (llvm_array r_words i64);
  points_to_bignum_st r_ptr r_d_ptr r_words;

  crucible_return (crucible_term {{ 1 : [32] }});
};

let bn_mod_exp_base_2_consttime_spec r_words = do {
  r_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  n_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  ctx_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_ctx");

  crucible_execute_func [r_ptr,
                         // Technically this should be N width * 64 * 2, but
                         // with the values we've chosen they're equivalent
                         crucible_term {{ `r_words * 64 * 2: [32] }},
                         n_ptr,
                         ctx_ptr];

  (r_d, r_d_ptr) <- ptr_to_fresh "r_d" (llvm_array r_words i64);
  points_to_bignum_st r_ptr r_d_ptr r_words;

  crucible_return (crucible_term {{ 1 : [32] }});
};

// TODO: Overriden because it calls into bn_add_words asm function that the
// override in the BN lib isn't working for
bn_mod_exp_base_2_consttime_ov <- crucible_llvm_unsafe_assume_spec
  m
  "bn_mod_exp_base_2_consttime"
  (bn_mod_exp_base_2_consttime_spec 1);


let bn_add_words_spec n = do {
  rp <- crucible_alloc (llvm_array n i64);
  (a, ap) <- ptr_to_fresh_readonly "a" (llvm_array n i64);
  (b, bp) <- ptr_to_fresh_readonly "b" (llvm_array n i64);
  crucible_execute_func [rp, ap, bp, (crucible_term {{ `n : [64] }})];
  let res = {{ ((0 : [1]) # (join (reverse a))) + ((0 : [1]) # (join (reverse b))) }};
  crucible_points_to rp (crucible_term {{ reverse (split`{each=64} (tail res)) }});
  crucible_return (crucible_term {{ if head res then 1 : [64] else 0 : [64] }});
};

BN_mod_mul_montgomery_8_ov <- crucible_llvm_unsafe_assume_spec
  m
  "BN_mod_mul_montgomery"
  (BN_mod_mul_montgomery_spec 8);

BN_mod_mul_montgomery_16_ov <- crucible_llvm_unsafe_assume_spec
  m
  "BN_mod_mul_montgomery"
  (BN_mod_mul_montgomery_spec 16);

// TODO: This override may cause problems when combined with blinding, which
// needs the 8 byte override, but there are no preconditions to differentiate
// them.  Perhaps a symbolic version that uses the input width of the modulus
// makes the most sense
BN_mod_mul_montgomery_1_ov <- crucible_llvm_unsafe_assume_spec
  m
  "BN_mod_mul_montgomery"
  (BN_mod_mul_montgomery_spec 1);

BN_mod_mul_montgomery_nonoverlap_1_ov <- crucible_llvm_unsafe_assume_spec
  m
  "BN_mod_mul_montgomery"
  (BN_mod_mul_montgomery_nonoverlap_spec 1);

BN_BLINDING_convert_ov <- crucible_llvm_unsafe_assume_spec
  m
  "BN_BLINDING_convert"
  // TODO: Check the output size
  (BN_BLINDING_convert_spec 16);

RAND_bytes_ov <- crucible_llvm_unsafe_assume_spec
  m
  "RAND_bytes"
  (RAND_bytes_spec 32);

rand_nonzero_ov <- crucible_llvm_unsafe_assume_spec
  m
  "rand_nonzero"
  (rand_nonzero_spec 29);

bn_neg_inv_mod_r_u64_ov <- crucible_llvm_unsafe_assume_spec
  m
  "bn_neg_inv_mod_r_u64"
  (bn_neg_inv_mod_r_u64_spec);

BN_mod_exp_mont_consttime_16_ov <- crucible_llvm_unsafe_assume_spec
  m
  "BN_mod_exp_mont_consttime"
  (BN_mod_exp_mont_consttime_spec 16);

BN_mod_exp_mont_consttime_8_ov <- crucible_llvm_unsafe_assume_spec
  m
  "BN_mod_exp_mont_consttime"
  (BN_mod_exp_mont_consttime_spec 8);

BN_mod_exp_mont_consttime_1_ov <- crucible_llvm_unsafe_assume_spec
  m
  "BN_mod_exp_mont_consttime"
  (BN_mod_exp_mont_consttime_spec 1);


// TODO: Why doesn't the proof of this go through?  Does it have to do with the
// re-interpret cast?
/*
BN_bn2bin_padded_same_size_ov <- crucible_llvm_unsafe_assume_spec
  m
  "BN_bn2bin_padded"
  (BN_bn2bin_padded_same_size_spec 8);
  */

// This override is here because BN_CTX contains an autogenerated BN_STACK,
// which this function iterates through and frees.  We lose info about this
// stack from the wrap_BN_mod_exp_mont override and rather than define it only
// to have it imediately freed I put this override here.
/*
BN_CTX_free_nonnull_ov <- crucible_llvm_unsafe_assume_spec
  m
  "BN_CTX_free"
  (BN_CTX_free_nonnull_spec);

BN_CTX_free_null_ov <- crucible_llvm_unsafe_assume_spec
  m
  "BN_CTX_free"
  (BN_CTX_free_null_spec);
  */

BN_mod_exp_mont_16_ov <- crucible_llvm_unsafe_assume_spec
  m
  "wrap_BN_mod_exp_mont"
  (wrap_BN_mod_exp_mont_spec 16);

// Unwrapped version of wrap_BN_mod_exp_mont_spec without overlapping memory
// regions
let BN_mod_exp_mont_spec r_words = do {
  r_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  a_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  p_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  m_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  // TODO: Technically ctx_ptr is not a const input to BN_mod_exp_mont_spec.
  // However, ctx_ptr is pretty much just a stack of bignums to use as temp
  // values, and BN_mod_exp_mont_spec pops off values that it pushes to the
  // stack, so from the algorithm's perspective, the stack is unchanged.  In
  // reality though, it's possible for BN_mod_exp_mont_spec to push enough to
  // realloc the stack (though I'm not sure whether this happens), and more
  // importantly, popping the stack does not zero it, so the memory itself will
  // be different for values beyond the tip of the stack.
  ctx_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_ctx");
  mont_ptr <- crucible_alloc_readonly (llvm_struct "struct.bn_mont_ctx_st");
  //points_to_bn_mont_ctx_st mont_ptr m;
  crucible_execute_func [r_ptr, a_ptr, p_ptr, m_ptr, ctx_ptr, mont_ptr];
  //r_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  (r_d, r_d_ptr) <- ptr_to_fresh "r_d" (llvm_array r_words i64);
  points_to_bignum_st r_ptr r_d_ptr r_words;

  crucible_return (crucible_term {{ 1 : [32] }});
};

let bn_mul_words_spec num = do {
  rp <- crucible_alloc (llvm_array num i64);
  (a, ap) <- ptr_to_fresh_readonly "a" (llvm_array num i64);
  w <- crucible_fresh_var "w" i64;
  crucible_execute_func [rp, ap, (crucible_term {{ `num : [64] }}), (crucible_term w)];
  let res = {{ split`{each=64} ((join ([0] # (reverse a))) * (0 # w)) }};
  crucible_points_to rp (crucible_term {{ reverse (tail res) }});
  crucible_return (crucible_term {{ head res }});
};

bn_mul_words_ov <- crucible_llvm_unsafe_assume_spec
  m
  "bn_mul_words"
  (bn_mul_words_spec 8);


BN_mod_exp_mont_8_ov <- crucible_llvm_unsafe_assume_spec
  m
  "BN_mod_exp_mont"
  (BN_mod_exp_mont_spec 8);

BN_mod_exp_mont_16_ov <- crucible_llvm_unsafe_assume_spec
  m
  "BN_mod_exp_mont"
  (BN_mod_exp_mont_spec 16);

// This is needed because BN_mod_exp_mont_spec isn't functionally correct.  I
// suspect we can remove this override once BN_mod_exp_mont_spec is correct.
let BN_equal_consttime_spec = do {
  a_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  b_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  crucible_execute_func [a_ptr, b_ptr];
  crucible_return (crucible_term {{ 1 : [32] }});
};

BN_equal_consttime_ov <- crucible_llvm_unsafe_assume_spec
  m
  "BN_equal_consttime"
  (BN_equal_consttime_spec);

  /*
bn_mont_n0_ov <- crucible_llvm_unsafe_assume_spec
  m
  "bn_mont_n0"
  (bn_mont_n0_spec);

bn_minimal_width_n_ov <- crucible_llvm_unsafe_assume_spec
  m
  "bn_minimal_width"
  (bn_minimal_width_n_spec 8);

BN_num_bytes_n_ov <- crucible_llvm_unsafe_assume_spec
  m
  "BN_num_bytes"
  (BN_num_bytes_n_spec 8);
  */

OPENSSL_realloc_nonnull_ov <- crucible_llvm_unsafe_assume_spec
  m
  "OPENSSL_realloc"
  // TODO: I'm not sure 32 is even the right old_size.  It surprisingly doesn't
  // seem to matter?  But the symbolic version doesn't work at all.  I guess it
  // works because the C only knows it's an i8*, but doesn't know how big the
  // underlying memory is
  (OPENSSL_realloc_nonnull_spec 32 64);

OPENSSL_realloc_null_ov <- crucible_llvm_unsafe_assume_spec
  m
  "OPENSSL_realloc"
  (OPENSSL_realloc_null_spec 256);

OPENSSL_free_null_ov <- crucible_llvm_unsafe_assume_spec
  m
  "OPENSSL_free"
  OPENSSL_free_null_spec;

CRYPTO_MUTEX_lock_read_ov <- crucible_llvm_unsafe_assume_spec
  m
  "CRYPTO_MUTEX_lock_read"
  CRYPTO_MUTEX_lock_spec;

CRYPTO_MUTEX_unlock_read_ov <- crucible_llvm_unsafe_assume_spec
  m
  "CRYPTO_MUTEX_unlock_read"
  CRYPTO_MUTEX_lock_spec;

CRYPTO_MUTEX_lock_write_ov <- crucible_llvm_unsafe_assume_spec
  m
  "CRYPTO_MUTEX_lock_write"
  CRYPTO_MUTEX_lock_spec;

CRYPTO_MUTEX_unlock_write_ov <- crucible_llvm_unsafe_assume_spec
  m
  "CRYPTO_MUTEX_unlock_write"
  CRYPTO_MUTEX_lock_spec;

// TODO: Just run the proof once its fixed
EVP_Digest_ov <- crucible_llvm_unsafe_assume_spec
  m
  "EVP_Digest"
  (EVP_Digest_spec 8);

let EVP_DigestFinal_ex_spec num = do {
  md_out_ptr <- crucible_alloc (llvm_array 32 (llvm_int 8));

  ctx_ptr <- crucible_alloc (llvm_struct "struct.env_md_ctx_st");

  digest_ptr <- crucible_alloc_readonly (llvm_struct "struct.env_md_st");
  points_to_env_md_st digest_ptr;

  sha256_ctx_ptr <- crucible_alloc (llvm_struct "struct.sha256_state_st");

  // TODO: This fails to match because block and sz are unreachable (do they
  // not exist at the call site?)
  //sha256_ctx <- fresh_sha256_state_st "sha256_ctx" num;
  //points_to_sha256_state_st sha256_ctx_ptr sha256_ctx;

  points_to_env_md_ctx_st ctx_ptr digest_ptr sha256_ctx_ptr;

  crucible_execute_func [ctx_ptr, md_out_ptr, crucible_null];

  //crucible_points_to md_out_ptr (crucible_term {{ split`{32} (SHAFinal sha256_ctx) }});
  //ctx_ptr <- crucible_alloc (llvm_struct "struct.env_md_ctx_st");
  //sha256_ctx_ptr <- crucible_alloc (llvm_struct "struct.sha256_state_st");
  // TODO: Acutally capture SHA effects
  md_out <- crucible_fresh_var "md_out" (llvm_array 32 i8);
  crucible_points_to md_out_ptr (crucible_term md_out);
  points_to_env_md_ctx_st ctx_ptr digest_ptr sha256_ctx_ptr;

  crucible_return (crucible_term {{ 1 : [32] }});
};
EVP_DigestFinal_ex_ov <- crucible_llvm_unsafe_assume_spec
  m
  "EVP_DigestFinal_ex"
  (EVP_DigestFinal_ex_spec 0);
  /*
EVP_DigestInit_ov <- crucible_llvm_unsafe_assume_spec
  m
  "EVP_DigestInit"
  (EVP_DigestInit_spec);
EVP_DigestUpdate_ov <- crucible_llvm_unsafe_assume_spec
  m
  "EVP_DigestUpdate"
  (EVP_DigestUpdate_spec 0 8);
  */


// Assume `OPENSSL_malloc` satisfies `OPENSSL_malloc_spec`
// TODO: I think the 48 byte malloc applies to rsa_impl.c:284 but it's not
// clear to me why rsa_size would have to be 48 bytes.  It seems like it could
// be any value between 0 and the modulus size in bytes (64 with the current
// setting).
/*
OPENSSL_malloc_ov_48 <- crucible_llvm_unsafe_assume_spec
  m
  "OPENSSL_malloc"
  (OPENSSL_malloc_spec 48);
// TODO: Where do these mallocs come from?
OPENSSL_malloc_ov_256 <- crucible_llvm_unsafe_assume_spec
  m
  "OPENSSL_malloc"
  (OPENSSL_malloc_spec 256);
OPENSSL_malloc_ov_40 <- crucible_llvm_unsafe_assume_spec
  m
  "OPENSSL_malloc"
  (OPENSSL_malloc_spec 40);
  */

/*
malloc_nums <- for (eval_list {{ [0 .. 256 : [64]] }})
  (\x -> (return (eval_int x)) : (TopLevel Int));
  */

// TODO: Where are all of these allocs comming from?  Run with --sim-verbose=3
// for stack traces on them and double check they're sensible.
let malloc_nums = [24, 32, 40, 48, 256];

OPENSSL_malloc_ovs <- for malloc_nums
  (\x -> crucible_llvm_unsafe_assume_spec m "OPENSSL_malloc" (OPENSSL_malloc_spec x));

OPENSSL_malloc_sym_ov <- crucible_llvm_unsafe_assume_spec
  m
  "OPENSSL_malloc"
  OPENSSL_malloc_sym_spec;

// TODO: Remove the 24 once you get the first thing to free here
let free_nums = [1, 24];
OPENSSL_free_nonnull_ovs <- for free_nums
  (\x -> crucible_llvm_unsafe_assume_spec m
         "OPENSSL_free"
         (OPENSSL_free_nonnull_spec x));

// value_barrier_w just returns its input (it exists to prevent the compiler
// from unding constant-time code)
let value_barrier_w_spec = do {
  a <- crucible_fresh_var "a" i64;
  crucible_execute_func [(crucible_term a)];
  crucible_return (crucible_term a);
};

value_barrier_w_ov <- crucible_llvm_unsafe_assume_spec
  m
  "value_barrier_w"
  value_barrier_w_spec;

let points_to_evp_pkey_ctx_st ptr pmeth_ptr pkey_ptr operation data_ptr = do {
  crucible_points_to (crucible_field ptr "pmeth") pmeth_ptr;
  crucible_points_to (crucible_field ptr "pkey") pkey_ptr;
  crucible_points_to (crucible_field ptr "operation")
                     (crucible_term {{ `operation : [32] }});
  crucible_points_to (crucible_field ptr "data") data_ptr;
};

let points_to_evp_pkey_method_st ptr = do {
  crucible_points_to (crucible_field ptr "encrypt")
                     (crucible_global "pkey_rsa_encrypt");
  crucible_points_to (crucible_field ptr "decrypt")
                     (crucible_global "pkey_rsa_decrypt");
};

let points_to_evp_pkey_st ptr rsa_ptr = do {
  crucible_points_to (crucible_field ptr "pkey") rsa_ptr;
  crucible_points_to (crucible_field ptr "ameth")
                     (crucible_global "rsa_asn1_meth");
};

// TODO: This implements the default RSA_METHOD, which is all NULL.  Do we want
// to support non-default RSA_METHOD structs?
let points_to_rsa_meth_st ptr = do {
  crucible_points_to (crucible_field ptr "size") crucible_null;
  crucible_points_to (crucible_field ptr "decrypt") crucible_null;
  crucible_points_to (crucible_field ptr "private_transform") crucible_null;
};

let points_to_rsa_st ptr
                     meth_ptr
                     n_ptr
                     e_ptr
                     d_ptr
                     flags
                     p_ptr
                     q_ptr
                     dmp1_ptr
                     dmq1_ptr
                     iqmp_ptr = do {
  crucible_points_to (crucible_field ptr "meth") meth_ptr;
  crucible_points_to (crucible_field ptr "n") n_ptr;
  crucible_points_to (crucible_field ptr "e") e_ptr;
  crucible_points_to (crucible_field ptr "d") d_ptr;
  crucible_points_to (crucible_field ptr "flags")
                     (crucible_term {{ `flags: [32] }});

  // Fields for the p+q case
  crucible_points_to (crucible_field ptr "p") p_ptr;
  crucible_points_to (crucible_field ptr "q") q_ptr;
  crucible_points_to (crucible_field ptr "dmp1") dmp1_ptr;
  crucible_points_to (crucible_field ptr "dmq1") dmq1_ptr;
  crucible_points_to (crucible_field ptr "iqmp") iqmp_ptr;
  crucible_points_to (crucible_field ptr "mont_p") crucible_null;
  crucible_points_to (crucible_field ptr "mont_q") crucible_null;
  crucible_points_to (crucible_field ptr "dmp1_fixed") crucible_null;
  crucible_points_to (crucible_field ptr "dmq1_fixed") crucible_null;
  crucible_points_to (crucible_field ptr "inv_small_mod_large_mont") crucible_null;

  // TODO: Should this field be null?  mont_n is a cache, and setting it to
  // forces the encrypt function to initialize the cache, which seems right
  // here.  Is there a reason it wouldn't be null?
  crucible_points_to (crucible_field ptr "mont_n") crucible_null;
  // Must be null for ensure_fixed_copy
  crucible_points_to (crucible_field ptr "d_fixed") crucible_null;

  // TODO: Setting this to zero skips the blinding cache invalidation step for
  // multithreaded decrypt on some (but not all) platforms.  Do we want to
  // check that?  SEtting this to 0 does not disable blinding, as the setup
  // function sets it to 1 after the cache clear step if it is zero.
  crucible_points_to (crucible_field ptr "num_blindings")
                     (crucible_term {{ 0 : [32] }});
  crucible_points_to (crucible_field ptr "blindings") crucible_null;
  crucible_points_to (crucible_field ptr "blindings_inuse") crucible_null;
  crucible_points_to (crucible_field ptr "blinding_fork_generation")
                     (crucible_term {{ 0 : [64] }});

  // private_key_frozen is a 1 bit bit-field of type `unsigned`, but the
  // compiler allocates 8 bits for it
  crucible_points_to (crucible_field ptr "private_key_frozen")
                     (crucible_term {{ 0 : [8] }});
};
/*
let BN_div_spec numerator_dmax divisor_dmax = do {
  //rem_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  //points_to_bignum_st rem_ptr crucible_null 0;
  //numerator_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  //(numerator, numerator_d_ptr) <- ptr_to_fresh_readonly "numerator" (llvm_array numerator_dmax i64);
  numerator_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  (numerator, numerator_d_ptr) <- ptr_to_fresh "numerator" (llvm_array numerator_dmax i64);
  points_to_bignum_st numerator_ptr numerator_d_ptr numerator_dmax;
  divisor_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  (divisor, divisor_d_ptr) <- ptr_to_fresh_readonly "divisor" (llvm_array divisor_dmax i64);
  points_to_bignum_st divisor_ptr divisor_d_ptr divisor_dmax;
  ctx_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_ctx");
  crucible_execute_func
    [ crucible_null // quotient_ptr
    , numerator_ptr // rem_ptr
    , numerator_ptr
    , divisor_ptr
    , ctx_ptr
    ];

  let rem_ptr = numerator_ptr;
  rem_d_ptr <- crucible_alloc (llvm_array divisor_dmax i64);
  crucible_points_to rem_d_ptr (crucible_term {{ take`{divisor_dmax} (reverse (split`{each=64} ((join (reverse numerator)) % (0 # (join (reverse divisor)))))) }});
  points_to_bignum_st rem_ptr rem_d_ptr divisor_dmax;
  crucible_return (crucible_term {{ 1 : [32] }});
};

BN_div_ov <- crucible_llvm_unsafe_assume_spec
  m
  "BN_div"
  (BN_div_spec 13 8);  // TODO: Where did these values come from?
  */

let BN_div_spec divisor_dmax = do {
  //rem_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  //points_to_bignum_st rem_ptr crucible_null 0;
  //numerator_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  //(numerator, numerator_d_ptr) <- ptr_to_fresh_readonly "numerator" (llvm_array numerator_dmax i64);
  numerator_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  divisor_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  ctx_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_ctx");
  crucible_execute_func
    [ crucible_null // quotient_ptr
    , numerator_ptr // rem_ptr
    , numerator_ptr
    , divisor_ptr
    , ctx_ptr
    ];

  let rem_ptr = numerator_ptr;
  rem_d_ptr <- crucible_alloc (llvm_array divisor_dmax i64);
  points_to_bignum_st rem_ptr rem_d_ptr divisor_dmax;
  crucible_return (crucible_term {{ 1 : [32] }});
};

BN_div_16_ov <- crucible_llvm_unsafe_assume_spec
  m
  "BN_div"
  (BN_div_spec 16);  // TODO: Where did these values come from?

BN_div_8_ov <- crucible_llvm_unsafe_assume_spec
  m
  "BN_div"
  (BN_div_spec 8);  // TODO: Where did these values come from?

let points_to_rsa_pkey_ctx ptr pad_mode md_ptr oaep_label_ptr oaep_labellen = do {
  // `pad_mode` is technically a 32 bit integer, but the compiler must pad the
  // space to 64 bits as the following element in the struct is a pointer.
  // We can treat this int like a 64-bit value as little-endian encoding
  // ensures the low order bytes end up at the lower address and fit in the 32
  // bits dedicated to the `pad_mode` field.
  crucible_points_to (crucible_elem ptr PAD_MODE_IDX)
                     (crucible_term {{ `pad_mode : [64] }});
  crucible_points_to (crucible_elem ptr TBUF_IDX) crucible_null;
  crucible_points_to (crucible_elem ptr MD_IDX) md_ptr;
  crucible_points_to (crucible_elem ptr MGF1MD_IDX) crucible_null;
  crucible_points_to (crucible_elem ptr OAEP_LABEL_IDX) oaep_label_ptr;
  crucible_points_to (crucible_elem ptr OAEP_LABELLEN_IDX)
                     (crucible_term {{ `oaep_labellen : [64] }});
};

/*
let EVP_PKEY_init = do {
  pkey <- crucible_alloc 
}
*/

/*
let rsa_st_init = do {

}
*/

// TODO: Verify this still works after reverting change to OPENSSL_PUT_ERROR
// (Initially changed because it requires some pthread functions and is
// orthogonal to what we want to prove).
// Potential problems:
//  * p_rsa.c:318: rsa->n might be underconstrained and trigger this
//    OPENSSL_PUT_ERROR.  Just need to properly set n to fix this.
// TODO: out_len must be >= modulus_bytes
let EVP_PKEY_encrypt_spec out_len in_len modulus_bytes pad_mode oaep_size = do {
  // TODO: Do I have to initialize this global?
  //crucible_alloc_global "g_thread_local_init_once";
  
  ctx_ptr <- crucible_alloc (llvm_struct "struct.evp_pkey_ctx_st");
  pmeth_ptr <- crucible_alloc (llvm_struct "struct.evp_pkey_method_st");
  points_to_evp_pkey_method_st pmeth_ptr;
  pkey_ptr <- crucible_alloc (llvm_struct "struct.evp_pkey_st");
  rsa_ptr <- crucible_alloc (llvm_struct "struct.rsa_st");
  meth_ptr <- crucible_alloc (llvm_struct "struct.rsa_meth_st");
  points_to_rsa_meth_st meth_ptr;
  n_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  let modulus_words = eval_int {{ ((`modulus_bytes + 7) / 8) : [64]}};
  (n_d, n_d_ptr) <- ptr_to_fresh "n_d" (llvm_array modulus_words i64);
  points_to_bignum_st n_ptr n_d_ptr modulus_words;
  // `n_d` must have a nonzero value in byte (modulus_bytes - 1) to be considered
  // `modulus_bytes` long.
  // TODO: Handle case where modulus_bytes is not a multiple of 8
  crucible_precond {{ (n_d ! 0) >= (2^^56) }};
  // `n_d` must be odd
  // TODO: I think this somehow breaks when OPENSSL_PUT_ERROR is properly
  // defined?
  crucible_precond {{ ((n_d @ 0) && 1) == 1 }};
  //crucible_precond {{ ((split`{each=8} (join n_d)) @ (`modulus_bytes - 1)) > 0 }};
  // TODO: If `modulus_bytes` is not a multiple of the word
  // size (8), then `n_d` must have all bytes above `modulus_bytes` zeroed
  // out.
  e_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  (e_d, e_d_ptr) <- ptr_to_fresh "e_d" i64;
  // e_d must be 33 bits or fewer wide
  crucible_precond {{ e_d <= (2 ^^ 33 - 1) }};
  points_to_bignum_st e_ptr e_d_ptr 1;
  // TODO: I just passed in nullptr for d_ptr here.  I think that should be
  // fine, but if this proof breaks, that's one place to look
  points_to_rsa_st rsa_ptr meth_ptr n_ptr e_ptr crucible_null 0 crucible_null crucible_null crucible_null crucible_null crucible_null;
  points_to_evp_pkey_st pkey_ptr rsa_ptr;
  // TODO: data_ptr actully points to an RSA_PKEY_CTX struct.  Be *very
  // careful* with getting the contents of this right.
  data_ptr <- crucible_alloc (llvm_array RSA_PKEY_CTX_WORDS i64);
  md_ptr <- crucible_alloc_readonly (llvm_struct "struct.env_md_st");
  points_to_env_md_st md_ptr;
  (oaep_label, oaep_label_ptr) <- ptr_to_fresh "oaep_label" (llvm_array oaep_size i8);
  points_to_rsa_pkey_ctx data_ptr pad_mode md_ptr oaep_label_ptr oaep_size;
  points_to_evp_pkey_ctx_st ctx_ptr pmeth_ptr pkey_ptr EVP_PKEY_OP_ENCRYPT data_ptr;

  out_ptr <- crucible_alloc (llvm_array out_len i8);

  out_len_ptr <- crucible_alloc i64;
  crucible_points_to out_len_ptr (crucible_term {{ `out_len : [64] }});

  (input, in_ptr) <- ptr_to_fresh_readonly "input" (llvm_array in_len i8);
  // TODO: This effectively makes input < n_d (whcih is required), but it does
  // so in a hacky way.  This precondition should directly reference n_d.
  // The interface is dumb so `input` is a big endian number but `n_d` is
  // little endian...
  crucible_precond {{ (input @ 0) == 0 }};

  // TODO: Fill these params in properly
  crucible_execute_func
    [ ctx_ptr
    , out_ptr
    , out_len_ptr
    , in_ptr
    , crucible_term {{ `in_len : [64] }}
    ];

  // TODO: The out stuff was commented out before.  Double check that it
  // still works
  out' <- crucible_fresh_var "out" (llvm_array out_len i8);
  crucible_points_to out_ptr (crucible_term out');

  crucible_points_to out_len_ptr (crucible_term {{ `out_len : [64] }});

  crucible_return (crucible_term {{ 1 : [32] }});
};

BN_bn2bin_padded_same_size_8_ov <- crucible_llvm_verify m "BN_bn2bin_padded"
  []
  true
  (BN_bn2bin_padded_same_size_spec 8)
  do {
    //(simplify basic_ss);
    //(print_goal);
    (w4_unint_yices []);
  };
BN_bn2bin_padded_same_size_16_ov <- crucible_llvm_verify m "BN_bn2bin_padded"
  []
  true
  (BN_bn2bin_padded_same_size_spec 16)
  do {
    //(simplify basic_ss);
    //(print_goal);
    (w4_unint_yices []);
  };

let RSA_padding_check_PKCS1_OAEP_mgf1_spec out_len max_out from_len param_len = do {
  
  (out, out_ptr) <- ptr_to_fresh "out" (llvm_array out_len i8);

  out_len_ptr <- crucible_alloc i64;
  crucible_points_to out_len_ptr (crucible_term {{ `out_len : [64] }});

  (from, from_ptr) <- ptr_to_fresh_readonly "from" (llvm_array from_len i8);

  (param, param_ptr) <- ptr_to_fresh_readonly "param" (llvm_array param_len i8);

  md_ptr <- crucible_alloc_readonly (llvm_struct "struct.env_md_st");
  points_to_env_md_st md_ptr;

  crucible_execute_func [ out_ptr,
                          out_len_ptr,
                          crucible_term {{ `max_out : [64] }},
                          from_ptr,
                          crucible_term {{ `from_len : [64] }},
                          param_ptr,
                          crucible_term {{ `param_len : [64] }},
                          md_ptr,
                          crucible_null ];

  ret <- crucible_fresh_var "ret" i32;
  crucible_postcond {{ (ret == 0) || (ret == 1) }};

  out' <- crucible_fresh_var "out" (llvm_array out_len i8);
  crucible_conditional_points_to {{ ret == 1 }} out_ptr (crucible_term out');

  // TODO: With padding this out_len_ptr value may not be known, just that it
  // must be less than or equal to out_len
  //crucible_points_to out_len_ptr (crucible_term {{ `out_len : [64] }});

  crucible_return (crucible_term {{ ret : [32] }});
};

let {{ ia32cap = [0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff] : [4][32] }};
let EVP_PKEY_decrypt_spec out_len in_len modulus_bytes d_words rsa_flags prime_words pad_mode oaep_size = do {
  // TODO: Do I have to initialize this global?
  //crucible_alloc_global "g_thread_local_init_once";
  // TODO: Might want postcondition that OPENSSL_ia32cap_P is unchanged too
  global_alloc_init "OPENSSL_ia32cap_P" {{ ia32cap }};
  
  ctx_ptr <- crucible_alloc (llvm_struct "struct.evp_pkey_ctx_st");
  pmeth_ptr <- crucible_alloc (llvm_struct "struct.evp_pkey_method_st");
  points_to_evp_pkey_method_st pmeth_ptr;
  pkey_ptr <- crucible_alloc (llvm_struct "struct.evp_pkey_st");
  rsa_ptr <- crucible_alloc (llvm_struct "struct.rsa_st");
  meth_ptr <- crucible_alloc (llvm_struct "struct.rsa_meth_st");
  points_to_rsa_meth_st meth_ptr;
  n_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  let modulus_words = eval_int {{ ((`modulus_bytes + 7) / 8) : [64]}};
  (n_d, n_d_ptr) <- ptr_to_fresh "n_d" (llvm_array modulus_words i64);
  points_to_bignum_st n_ptr n_d_ptr modulus_words;
  // `n_d` must have a nonzero value in byte (modulus_bytes - 1) to be considered
  // `modulus_bytes` long.
  // TODO: Handle case where modulus_bytes is not a multiple of 8
  crucible_precond {{ (n_d ! 0) >= (2^^56) }};
  // `n_d` must be odd
  // TODO: I think this somehow breaks when OPENSSL_PUT_ERROR is properly
  // defined?
  crucible_precond {{ ((n_d @ 0) && 1) == 1 }};
  //crucible_precond {{ ((split`{each=8} (join n_d)) @ (`modulus_bytes - 1)) > 0 }};
  // TODO: If `modulus_bytes` is not a multiple of the word
  // size (8), then `n_d` must have all bytes above `modulus_bytes` zeroed
  // out.

  e_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  (e_d, e_d_ptr) <- ptr_to_fresh "e_d" i64;
  // e_d must be 33 bits or fewer wide
  crucible_precond {{ e_d <= (2 ^^ 33 - 1) }};
  points_to_bignum_st e_ptr e_d_ptr 1;

  d_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  (d_d, d_d_ptr) <- ptr_to_fresh "d_d" (llvm_array d_words i64);
  points_to_bignum_st d_ptr d_d_ptr d_words;

  if eval_bool {{ `prime_words == 0 }} then do {
    // No CRM.  Leave p+q (and related fields) null
    points_to_rsa_st rsa_ptr
                     meth_ptr
                     n_ptr
                     e_ptr
                     d_ptr
                     rsa_flags
                     crucible_null
                     crucible_null
                     crucible_null
                     crucible_null
                     crucible_null;
  } else do {
    // CRM case
    // Fields for p+q case
    // TODO: guard behind prime_words being non-zero.  Otherwise make these null
    p_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
    (p_d, p_d_ptr) <- ptr_to_fresh "p_d" (llvm_array prime_words i64);
    crucible_precond {{ ((p_d @ 0) && 1) == 1 }};  // p must be odd
    points_to_bignum_st p_ptr p_d_ptr prime_words;
    q_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
    (q_d, q_d_ptr) <- ptr_to_fresh "q_d" (llvm_array prime_words i64);
    crucible_precond {{ ((q_d @ 0) && 1) == 1 }};  // q must be odd
    points_to_bignum_st q_ptr q_d_ptr prime_words;
    dmp1_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
    (dmp1_d, dmp1_d_ptr) <- ptr_to_fresh "dmp1_d" (llvm_array prime_words i64);
    points_to_bignum_st dmp1_ptr dmp1_d_ptr prime_words;
    dmq1_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
    (dmq1_d, dmq1_d_ptr) <- ptr_to_fresh "dmq1_d" (llvm_array prime_words i64);
    points_to_bignum_st dmq1_ptr dmq1_d_ptr prime_words;
    iqmp_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
    (iqmp_d, iqmp_d_ptr) <- ptr_to_fresh "iqmp_d" (llvm_array prime_words i64);
    points_to_bignum_st iqmp_ptr iqmp_d_ptr prime_words;
    points_to_rsa_st rsa_ptr
                     meth_ptr
                     n_ptr
                     e_ptr
                     d_ptr
                     rsa_flags
                     p_ptr
                     q_ptr
                     dmp1_ptr
                     dmq1_ptr
                     iqmp_ptr;
  };
  points_to_evp_pkey_st pkey_ptr rsa_ptr;
  // TODO: data_ptr actully points to an RSA_PKEY_CTX struct.  Be *very
  // careful* with getting the contents of this right.
  data_ptr <- crucible_alloc (llvm_array RSA_PKEY_CTX_WORDS i64);
  md_ptr <- crucible_alloc_readonly (llvm_struct "struct.env_md_st");
  points_to_env_md_st md_ptr;
  (oaep_label, oaep_label_ptr) <- ptr_to_fresh "oaep_label" (llvm_array oaep_size i8);
  points_to_rsa_pkey_ctx data_ptr pad_mode md_ptr oaep_label_ptr oaep_size;
  points_to_evp_pkey_ctx_st ctx_ptr pmeth_ptr pkey_ptr EVP_PKEY_OP_DECRYPT data_ptr;

  (out, out_ptr) <- ptr_to_fresh "out" (llvm_array out_len i8);

  out_len_ptr <- crucible_alloc i64;
  crucible_points_to out_len_ptr (crucible_term {{ `out_len : [64] }});

  (input, in_ptr) <- ptr_to_fresh_readonly "input" (llvm_array in_len i8);
  // TODO: This effectively makes input < n_d (whcih is required), but it does
  // so in a hacky way.  This precondition should directly reference n_d.
  // The interface is dumb so `input` is a big endian number but `n_d` is
  // little endian...
  crucible_precond {{ (input @ 0) == 0 }};

  // TODO: Fill these params in properly
  crucible_execute_func
    [ ctx_ptr
    , out_ptr
    , out_len_ptr
    , in_ptr
    , crucible_term {{ `in_len : [64] }}
    ];

  ret <- crucible_fresh_var "ret" i32;

  out' <- crucible_fresh_var "out" (llvm_array out_len i8);
  crucible_conditional_points_to {{ ret == 1 }} out_ptr (crucible_term out');

  // TODO: With padding this out_len_ptr value may not be known, just that it
  // must be less than or equal to out_len
  //crucible_points_to out_len_ptr (crucible_term {{ `out_len : [64] }});

  crucible_return (crucible_term {{ ret : [32] }});
    /*
  out' <- crucible_fresh_var "out" (llvm_array out_len i8);
  crucible_points_to out_ptr (crucible_term out');
  crucible_return (crucible_term {{ 1 : [32] }});
  */
};

/*
// Padding mode: RSA_PKCS1_OAEP_PADDING
crucible_llvm_verify m "EVP_PKEY_encrypt"
  (concat
   OPENSSL_free_nonnull_ovs
   (concat
    OPENSSL_malloc_ovs
    [value_barrier_w_ov,
     OPENSSL_free_null_ov,
     OPENSSL_malloc_sym_ov,
     CRYPTO_MUTEX_lock_read_ov,
     CRYPTO_MUTEX_unlock_read_ov,
     CRYPTO_MUTEX_lock_write_ov,
     CRYPTO_MUTEX_unlock_write_ov,
     OPENSSL_realloc_null_ov,
     OPENSSL_realloc_nonnull_ov,
     BN_mod_exp_mont_16_ov,
     BN_bn2bin_padded_same_size_16_ov,
     bn_neg_inv_mod_r_u64_ov,
     rand_nonzero_ov,
     EVP_Digest_ov,  // TODO: Do I need this override?  Could removing it speed this up?  It doesn't seem necesary for decrypt.
     EVP_DigestFinal_ex_ov,
     //EVP_DigestInit_ov,
     //EVP_DigestUpdate_ov,
     RAND_bytes_ov,
     sha256_block_data_order_spec,
     OPENSSL_cleanse_ov,
     //BN_CTX_free_null_ov,
     //BN_CTX_free_nonnull_ov,
     BN_div_16_ov//,
     //bn_mont_n0_ov,
     //bn_minimal_width_n_ov,
     /*BN_num_bytes_n_ov*/]))
  //(concat [value_barrier_w_ov] OPENSSL_malloc_ovs)
  true
  (EVP_PKEY_encrypt_spec 128 32 128 RSA_PKCS1_OAEP_PADDING 8)
  do {
    //(simplify basic_ss);
    //(print_goal);
    (w4_unint_yices []);
  };
*/

/*
// Padding mode: RSA_NO_PADDING
crucible_llvm_verify m "EVP_PKEY_encrypt"
  (concat
   OPENSSL_free_nonnull_ovs
   (concat
    OPENSSL_malloc_ovs
    [value_barrier_w_ov,
     OPENSSL_free_null_ov,
     OPENSSL_malloc_sym_ov,
     CRYPTO_MUTEX_lock_read_ov,
     CRYPTO_MUTEX_unlock_read_ov,
     CRYPTO_MUTEX_lock_write_ov,
     CRYPTO_MUTEX_unlock_write_ov,
     OPENSSL_realloc_null_ov,
     OPENSSL_realloc_nonnull_ov,
     BN_mod_exp_mont_ov,
     BN_bn2bin_padded_same_size_ov,
     bn_neg_inv_mod_r_u64_ov,
     //BN_CTX_free_null_ov,
     //BN_CTX_free_nonnull_ov,
     BN_div_8_ov//,
     //bn_mont_n0_ov,
     //bn_minimal_width_n_ov,
     /*BN_num_bytes_n_ov*/]))
  //(concat [value_barrier_w_ov] OPENSSL_malloc_ovs)
  true
  (EVP_PKEY_encrypt_spec 64 64 64 RSA_NO_PADDING)
  do {
    //(simplify basic_ss);
    //(print_goal);
    (w4_unint_yices []);
  };
*/

let constant_time_eq_w_spec = do {
  a <- crucible_fresh_var "a" i64;
  b <- crucible_fresh_var "b" i64;
  crucible_execute_func [crucible_term a, crucible_term b];
  // TODO: just do a crucible return of a cryptol expression with an ite in it,
  // rather than an eval_bool with crucible_returns
  crucible_return (crucible_term {{
    if a == b then
      ~(0 : [64])
    else
      0 : [64]
  }});
};

constant_time_eq_w_ov <- crucible_llvm_unsafe_assume_spec
  m
  "constant_time_eq_w"
  (constant_time_eq_w_spec);

let constant_time_select_w_spec = do {
  mask <- crucible_fresh_var "mask" i64;
  a <- crucible_fresh_var "a" i64;
  b <- crucible_fresh_var "b" i64;
  crucible_execute_func [crucible_term mask, crucible_term a, crucible_term b];
  // TODO: just do a crucible return of a cryptol expression with an ite in it,
  // rather than an eval_bool with crucible_returns
  crucible_return (crucible_term {{ if mask == 0 then b else a }});
};

constant_time_select_w_ov <- crucible_llvm_unsafe_assume_spec
  m
  "constant_time_select_w"
  (constant_time_select_w_spec);

// TODO: Probably don't need all of these overrides (ex. CRYPTO_MUTEX*)
RSA_padding_check_PKCS1_OAEP_mgf1_ov <- crucible_llvm_verify
  m
  "RSA_padding_check_PKCS1_OAEP_mgf1"
  (concat
   OPENSSL_free_nonnull_ovs
   (concat
    OPENSSL_malloc_ovs
    [value_barrier_w_ov,
     OPENSSL_free_null_ov,
     OPENSSL_malloc_sym_ov,
     CRYPTO_MUTEX_lock_read_ov,
     CRYPTO_MUTEX_unlock_read_ov,
     CRYPTO_MUTEX_lock_write_ov,
     CRYPTO_MUTEX_unlock_write_ov,
     OPENSSL_realloc_null_ov,
     OPENSSL_realloc_nonnull_ov,
     sha256_block_data_order_spec,
     constant_time_eq_w_ov,
     constant_time_select_w_ov,
     EVP_DigestFinal_ex_ov]))
  true
  (RSA_padding_check_PKCS1_OAEP_mgf1_spec 72 72 72 1)
  do {
    //(simplify basic_ss);
    //(print_goal);
    (w4_unint_yices []);
  };

  /*
// -CRM -blinding
crucible_llvm_verify m "EVP_PKEY_decrypt"
  (concat
   OPENSSL_free_nonnull_ovs
   (concat
    OPENSSL_malloc_ovs
    [value_barrier_w_ov,
     OPENSSL_free_null_ov,
     OPENSSL_malloc_sym_ov,
     CRYPTO_MUTEX_lock_read_ov,
     CRYPTO_MUTEX_unlock_read_ov,
     CRYPTO_MUTEX_lock_write_ov,
     CRYPTO_MUTEX_unlock_write_ov,
     OPENSSL_realloc_null_ov,
     OPENSSL_realloc_nonnull_ov,
     BN_bn2bin_padded_same_size_16_ov,
     BN_mod_exp_mont_consttime_16_ov,
     BN_mod_exp_mont_16_ov,
     BN_equal_consttime_ov,
     bn_neg_inv_mod_r_u64_ov,
     sha256_block_data_order_spec,
     RSA_padding_check_PKCS1_OAEP_mgf1_ov,
     EVP_DigestFinal_ex_ov,
     BN_div_16_ov]))
  true
  (EVP_PKEY_decrypt_spec 128 128 128 8 RSA_FLAG_NO_BLINDING 0 RSA_PKCS1_OAEP_PADDING 1)
  do {
    //(simplify basic_ss);
    //(print_goal);
    (w4_unint_yices []);
  };
  */

/*
// -CRM +blinding
crucible_llvm_verify m "EVP_PKEY_decrypt"
  (concat
   OPENSSL_free_nonnull_ovs
   (concat
    OPENSSL_malloc_ovs
    [value_barrier_w_ov,
     OPENSSL_free_null_ov,
     OPENSSL_malloc_sym_ov,
     CRYPTO_MUTEX_lock_read_ov,
     CRYPTO_MUTEX_unlock_read_ov,
     CRYPTO_MUTEX_lock_write_ov,
     CRYPTO_MUTEX_unlock_write_ov,
     OPENSSL_realloc_null_ov,
     OPENSSL_realloc_nonnull_ov,
     BN_bn2bin_padded_same_size_16_ov,
     BN_mod_exp_mont_consttime_16_ov,
     BN_mod_exp_mont_16_ov,
     bn_neg_inv_mod_r_u64_ov,
     CRYPTO_get_fork_generation_ov,
     BN_BLINDING_convert_ov,
     BN_equal_consttime_ov,
     BN_mod_mul_montgomery_16_ov,
     sha256_block_data_order_spec,
     EVP_DigestFinal_ex_ov,
     //BN_CTX_free_null_ov,
     //BN_CTX_free_nonnull_ov,
     BN_div_16_ov//,
     //bn_mont_n0_ov,
     //bn_minimal_width_n_ov,
     /*BN_num_bytes_n_ov*/]))
  //(concat [value_barrier_w_ov] OPENSSL_malloc_ovs)
  true
  (EVP_PKEY_decrypt_spec 128 128 128 8 0 0 RSA_PKCS1_OAEP_PADDING 1)
  do {
    //(simplify basic_ss);
    //(print_goal);
    (w4_unint_yices []);
  };
*/

/*
// +CRM -blinding
crucible_llvm_verify m "EVP_PKEY_decrypt"
  (concat
   OPENSSL_free_nonnull_ovs
   (concat
    OPENSSL_malloc_ovs
    [value_barrier_w_ov,
     OPENSSL_free_null_ov,
     OPENSSL_malloc_sym_ov,
     CRYPTO_MUTEX_lock_read_ov,
     CRYPTO_MUTEX_unlock_read_ov,
     CRYPTO_MUTEX_lock_write_ov,
     CRYPTO_MUTEX_unlock_write_ov,
     OPENSSL_realloc_null_ov,
     OPENSSL_realloc_nonnull_ov,
     BN_bn2bin_padded_same_size_16_ov,
     BN_mod_exp_mont_consttime_1_ov,
     BN_mod_exp_mont_16_ov,
     BN_equal_consttime_ov,
     bn_neg_inv_mod_r_u64_ov,
     bn_mod_exp_base_2_consttime_ov,
     BN_mod_mul_montgomery_nonoverlap_1_ov,
     mod_exp_ov,
     sha256_block_data_order_spec,
     EVP_DigestFinal_ex_ov,
     BN_mod_mul_montgomery_1_ov,  // TODO: Don't use this as is with blinding
     BN_div_16_ov]))
  true
  (EVP_PKEY_decrypt_spec 128 128 128 8 RSA_FLAG_NO_BLINDING 1 RSA_PKCS1_OAEP_PADDING 1)
  do {
    //(simplify basic_ss);
    //(print_goal);
    (w4_unint_yices []);
  };

// +CRM +blinding
crucible_llvm_verify m "EVP_PKEY_decrypt"
  (concat
   OPENSSL_free_nonnull_ovs
   (concat
    OPENSSL_malloc_ovs
    [value_barrier_w_ov,
     OPENSSL_free_null_ov,
     OPENSSL_malloc_sym_ov,
     CRYPTO_MUTEX_lock_read_ov,
     CRYPTO_MUTEX_unlock_read_ov,
     CRYPTO_MUTEX_lock_write_ov,
     CRYPTO_MUTEX_unlock_write_ov,
     OPENSSL_realloc_null_ov,
     OPENSSL_realloc_nonnull_ov,
     BN_bn2bin_padded_same_size_16_ov,
     BN_mod_exp_mont_consttime_1_ov,
     BN_mod_exp_mont_16_ov,
     CRYPTO_get_fork_generation_ov,
     BN_BLINDING_convert_ov,
     BN_equal_consttime_ov,
     bn_neg_inv_mod_r_u64_ov,
     bn_mod_exp_base_2_consttime_ov,
     BN_mod_mul_montgomery_nonoverlap_1_ov,
     mod_exp_ov,
     sha256_block_data_order_spec,
     EVP_DigestFinal_ex_ov,
     // Use wider 16 byte mod_mul_montgomery ov to support blinding.  This will
     // need to be fine tuned for functional correctness, as in practice the
     // calls used during blinding and CRM will produce different width outputs
     BN_mod_mul_montgomery_16_ov,
     BN_div_16_ov]))
  true
  (EVP_PKEY_decrypt_spec 128 128 128 8 0 1 RSA_PKCS1_OAEP_PADDING 1)
  do {
    //(simplify basic_ss);
    //(print_goal);
    (w4_unint_yices []);
  };
  */
