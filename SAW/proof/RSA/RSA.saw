// TODO: Copyright notice
// TODO: Split into multiple files

enable_experimental;

m <- llvm_load_module "../../build/llvm/crypto/crypto_test.bc";

import "../../../cryptol-specs/Primitive/Asymmetric/Scheme/RSAES_OAEP_SHA256.cry";

//include "../common/helpers.saw";
include "../SHA256/SHA256.saw";
include "../common/internal.saw";
include "../common/memory.saw";
include "memory.saw";
include "../BN/BN.saw";
include "BN.saw";

///////////////////////////////////////////////////////////////////////////////
// Constants
///////////////////////////////////////////////////////////////////////////////

let EVP_PKEY_OP_ENCRYPT = 64;
let EVP_PKEY_OP_DECRYPT = 128;
let RSA_PKCS1_OAEP_PADDING = 4;
//let RSA_PKEY_CTX_SIZE = eval_int {{ (8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8) : [64] }};
// RSA_PKEY_CTX is a mix of 9 ints and pointers.  However, no two ints appear
// consecutively in the struct, so the compiler must pad them out with an extra
// 32 bits on the end.  This combined with little-endian encoding means we can
// abstract over the struct as an array of 9 64-bit integers.
let RSA_PKEY_CTX_WORDS = 9;
let PAD_MODE_IDX = 2;
let MD_IDX = 3;
let MGF1MD_IDX = 4;
let TBUF_IDX = 6;
let OAEP_LABEL_IDX = 7;
let OAEP_LABELLEN_IDX = 8;

let RSA_FLAG_NO_BLINDING = 8;

///////////////////////////////////////////////////////////////////////////////
// Structure definitions
///////////////////////////////////////////////////////////////////////////////

let points_to_bn_blinding_st ptr Ai_ptr = do {
  crucible_points_to (crucible_field ptr "Ai") Ai_ptr;
};

let points_to_evp_pkey_ctx_st ptr pmeth_ptr pkey_ptr operation data_ptr = do {
  crucible_points_to (crucible_field ptr "pmeth") pmeth_ptr;
  crucible_points_to (crucible_field ptr "pkey") pkey_ptr;
  crucible_points_to (crucible_field ptr "operation")
                     (crucible_term {{ `operation : [32] }});
  crucible_points_to (crucible_field ptr "data") data_ptr;
};

let points_to_evp_pkey_method_st ptr = do {
  crucible_points_to (crucible_field ptr "encrypt")
                     (crucible_global "pkey_rsa_encrypt");
  crucible_points_to (crucible_field ptr "decrypt")
                     (crucible_global "pkey_rsa_decrypt");
};

let points_to_evp_pkey_st ptr rsa_ptr = do {
  crucible_points_to (crucible_field ptr "pkey") rsa_ptr;
  crucible_points_to (crucible_field ptr "ameth")
                     (crucible_global "rsa_asn1_meth");
};

// TODO: This implements the default RSA_METHOD, which is all NULL.  Do we want
// to support non-default RSA_METHOD structs?
let points_to_rsa_meth_st ptr = do {
  crucible_points_to (crucible_field ptr "size") crucible_null;
  crucible_points_to (crucible_field ptr "decrypt") crucible_null;
  crucible_points_to (crucible_field ptr "private_transform") crucible_null;
};

let points_to_rsa_st ptr
                     meth_ptr
                     n_ptr
                     e_ptr
                     d_ptr
                     flags
                     p_ptr
                     q_ptr
                     dmp1_ptr
                     dmq1_ptr
                     iqmp_ptr = do {
  crucible_points_to (crucible_field ptr "meth") meth_ptr;
  crucible_points_to (crucible_field ptr "n") n_ptr;
  crucible_points_to (crucible_field ptr "e") e_ptr;
  crucible_points_to (crucible_field ptr "d") d_ptr;
  crucible_points_to (crucible_field ptr "flags")
                     (crucible_term {{ `flags: [32] }});

  // Fields for the p+q case
  crucible_points_to (crucible_field ptr "p") p_ptr;
  crucible_points_to (crucible_field ptr "q") q_ptr;
  crucible_points_to (crucible_field ptr "dmp1") dmp1_ptr;
  crucible_points_to (crucible_field ptr "dmq1") dmq1_ptr;
  crucible_points_to (crucible_field ptr "iqmp") iqmp_ptr;
  crucible_points_to (crucible_field ptr "mont_p") crucible_null;
  crucible_points_to (crucible_field ptr "mont_q") crucible_null;
  crucible_points_to (crucible_field ptr "dmp1_fixed") crucible_null;
  crucible_points_to (crucible_field ptr "dmq1_fixed") crucible_null;
  crucible_points_to (crucible_field ptr "inv_small_mod_large_mont") crucible_null;

  // TODO: Should this field be null?  mont_n is a cache, and setting it to
  // forces the encrypt function to initialize the cache, which seems right
  // here.  Is there a reason it wouldn't be null?
  crucible_points_to (crucible_field ptr "mont_n") crucible_null;
  // Must be null for ensure_fixed_copy
  crucible_points_to (crucible_field ptr "d_fixed") crucible_null;

  // TODO: Setting this to zero skips the blinding cache invalidation step for
  // multithreaded decrypt on some (but not all) platforms.  Do we want to
  // check that?  SEtting this to 0 does not disable blinding, as the setup
  // function sets it to 1 after the cache clear step if it is zero.
  crucible_points_to (crucible_field ptr "num_blindings")
                     (crucible_term {{ 0 : [32] }});
  crucible_points_to (crucible_field ptr "blindings") crucible_null;
  crucible_points_to (crucible_field ptr "blindings_inuse") crucible_null;
  crucible_points_to (crucible_field ptr "blinding_fork_generation")
                     (crucible_term {{ 0 : [64] }});

  // private_key_frozen is a 1 bit bit-field of type `unsigned`, but the
  // compiler allocates 8 bits for it
  crucible_points_to (crucible_field ptr "private_key_frozen")
                     (crucible_term {{ 0 : [8] }});
};
let points_to_rsa_pkey_ctx ptr pad_mode md_ptr oaep_label_ptr oaep_labellen = do {
  // `pad_mode` is technically a 32 bit integer, but the compiler must pad the
  // space to 64 bits as the following element in the struct is a pointer.
  // We can treat this int like a 64-bit value as little-endian encoding
  // ensures the low order bytes end up at the lower address and fit in the 32
  // bits dedicated to the `pad_mode` field.
  crucible_points_to (crucible_elem ptr PAD_MODE_IDX)
                     (crucible_term {{ `pad_mode : [64] }});
  crucible_points_to (crucible_elem ptr TBUF_IDX) crucible_null;
  crucible_points_to (crucible_elem ptr MD_IDX) md_ptr;
  crucible_points_to (crucible_elem ptr MGF1MD_IDX) crucible_null;
  crucible_points_to (crucible_elem ptr OAEP_LABEL_IDX) oaep_label_ptr;
  crucible_points_to (crucible_elem ptr OAEP_LABELLEN_IDX)
                     (crucible_term {{ `oaep_labellen : [64] }});
};

///////////////////////////////////////////////////////////////////////////////
// Function specifications
///////////////////////////////////////////////////////////////////////////////

let mod_exp_spec r0_words = do {
  r0_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  I_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");

  // *rsa is not marked const in mod_exp, but in this instance it's not
  // modified.  The only part of mod_exp that could mutate *rsa is
  // freeze_private_key, but rsa_default_private_transform already calls
  // freeze_private_key before mod_exp, so the subsequent freeze_private_key
  // call has no effect, meaning *rsa is unmodified.
  rsa_ptr <- crucible_alloc_readonly (llvm_struct "struct.rsa_st");

  ctx_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_ctx");
  crucible_execute_func [r0_ptr, I_ptr, rsa_ptr, ctx_ptr];
  (r0_d, r0_d_ptr) <- ptr_to_fresh "r0_d" (llvm_array r0_words i64);
  points_to_bignum_st_same r0_ptr r0_d_ptr r0_words;
  crucible_return (crucible_term {{ 1 : [32] }});
};


let constant_time_eq_w_spec = do {
  a <- crucible_fresh_var "a" i64;
  b <- crucible_fresh_var "b" i64;
  crucible_execute_func [crucible_term a, crucible_term b];
  // TODO: just do a crucible return of a cryptol expression with an ite in it,
  // rather than an eval_bool with crucible_returns
  crucible_return (crucible_term {{
    if a == b then
      ~(0 : [64])
    else
      0 : [64]
  }});
};

oaep_random_out <- crucible_declare_ghost_state "oaep_random_out";
let RAND_bytes_spec size = do {
  k <- crucible_fresh_cryptol_var "k" {| [size][8] |};
  crucible_ghost_value oaep_random_out k;

  out_ptr <- crucible_alloc (llvm_array size i8);
  crucible_execute_func [out_ptr, crucible_term {{ `size : [64] }}];

  crucible_points_to out_ptr (crucible_term k);

  // RAND_bytes always returns 1
  crucible_return (crucible_term {{ 1 : [32] }});
};

// TODO: I overrode this for two reasons:
// 1. It has an annoying random within a range for bignums call, which I would
// have tried to override, if it weren't for:
// 2. It can probabilistically fail!  If it randomly picks values that aren't
// invertible it will fail.  In theory SAW should find this counterexample.  In
// practice, this is equivalent to factoring mont->N, so I bet SAW will just
// hang, but I haven't tried it.  The function calls into bn_blinding_update,
// which does a whole sequence of operations.  I'm not sure which one(s) fail
// in the failure case, but there may be a way to override just that function
// to say it returns 1?  In any case, that will almost certainly require
// knowing p and q, but a whole path through the decrypt function doesn't have
// those factors, so I'm not sure it's even worth investigating that fix.
//
// At the end of the day, the postcondition for the decrypt w/ blinding proof
// will be that if decrypt function returns 1, then the output vector is
// correct.
let BN_BLINDING_convert_spec words = do {
  let num_bits = eval_size {| words * 64 |};
  n_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  b_ptr <- crucible_alloc (llvm_struct "struct.bn_blinding_st");
  e_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  (N_d, N_d_ptr) <- ptr_to_fresh_readonly "N_d" (llvm_int num_bits);
  mont_ptr <- pointer_to_bn_mont_ctx_st words N_d_ptr N_d;

  ctx_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_ctx");

  crucible_execute_func [n_ptr, b_ptr, e_ptr, mont_ptr, ctx_ptr];

  // TODO: I almost certainly need to say something about n_ptr and b_ptr here
  // TODO: Look at the comment on blinding.c:203.  Does this mean n is
  // unchanged by the exit of the function?

  (n_d, n_d_ptr) <- ptr_to_fresh "n_d" (llvm_array words i64);
  points_to_bignum_st_same n_ptr n_d_ptr words;

  Ai_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  points_to_bn_blinding_st b_ptr Ai_ptr;

  crucible_return (crucible_term {{ 1 : [32] }});
};

let EVP_DigestFinal_ex_spec num = do {
  md_out_ptr <- crucible_alloc (llvm_array 32 (llvm_int 8));

  ctx_ptr <- crucible_alloc (llvm_struct "struct.env_md_ctx_st");

  digest_ptr <- crucible_alloc_readonly (llvm_struct "struct.env_md_st");
  points_to_env_md_st digest_ptr;

  sha256_ctx_ptr <- crucible_alloc (llvm_struct "struct.sha256_state_st");

  // TODO: This fails to match because block and sz are unreachable (do they
  // not exist at the call site?)
  //sha256_ctx <- fresh_sha256_state_st "sha256_ctx" num;
  //points_to_sha256_state_st sha256_ctx_ptr sha256_ctx;

  points_to_env_md_ctx_st ctx_ptr digest_ptr sha256_ctx_ptr;

  crucible_execute_func [ctx_ptr, md_out_ptr, crucible_null];

  //crucible_points_to md_out_ptr (crucible_term {{ split`{32} (SHAFinal sha256_ctx) }});
  //ctx_ptr <- crucible_alloc (llvm_struct "struct.env_md_ctx_st");
  //sha256_ctx_ptr <- crucible_alloc (llvm_struct "struct.sha256_state_st");
  // TODO: Acutally capture SHA effects
  md_out <- crucible_fresh_var "md_out" (llvm_array 32 i8);
  crucible_points_to md_out_ptr (crucible_term md_out);
  points_to_env_md_ctx_st ctx_ptr digest_ptr sha256_ctx_ptr;

  crucible_return (crucible_term {{ 1 : [32] }});
};

let RSA_padding_add_PKCS1_OAEP_mgf1_spec to_len from_len param_len = do {
  k <- crucible_fresh_cryptol_var "k" {| [SHA256_DIGEST_LENGTH][8] |};
  crucible_ghost_value oaep_random_out k;

  to_ptr <- crucible_alloc (llvm_array to_len i8);

  (from, from_ptr) <- ptr_to_fresh_readonly "from" (llvm_array from_len i8);

  (param, param_ptr) <- ptr_to_fresh_readonly "param" (llvm_array param_len i8);

  md_ptr <- crucible_alloc_readonly (llvm_struct "struct.env_md_st");
  points_to_env_md_st md_ptr;

  crucible_execute_func [ to_ptr,
                          crucible_term {{ `to_len : [64] }},
                          from_ptr,
                          crucible_term {{ `from_len : [64] }},
                          param_ptr,
                          crucible_term {{ `param_len : [64] }},
                          md_ptr,
                          crucible_null ];

  crucible_points_to to_ptr (crucible_term {{
      split`{each=8} (integerToBV`{to_len * 8} (EME_OAEP_encode_integer`{param_len, from_len} k (integerFromBV (join from), integerFromBV (join param)))) }});

  crucible_return (crucible_term {{ 1 : [32] }});
};

let RSA_padding_check_PKCS1_OAEP_mgf1_spec out_len max_out from_len param_len = do {
  (out, out_ptr) <- ptr_to_fresh "out" (llvm_array out_len i8);

  out_len_ptr <- crucible_alloc i64;
  crucible_points_to out_len_ptr (crucible_term {{ `out_len : [64] }});

  (from, from_ptr) <- ptr_to_fresh_readonly "from" (llvm_array from_len i8);

  (param, param_ptr) <- ptr_to_fresh_readonly "param" (llvm_array param_len i8);

  md_ptr <- crucible_alloc_readonly (llvm_struct "struct.env_md_st");
  points_to_env_md_st md_ptr;

  crucible_execute_func [ out_ptr,
                          out_len_ptr,
                          crucible_term {{ `max_out : [64] }},
                          from_ptr,
                          crucible_term {{ `from_len : [64] }},
                          param_ptr,
                          crucible_term {{ `param_len : [64] }},
                          md_ptr,
                          crucible_null ];

  ret <- crucible_fresh_var "ret" i32;
  crucible_postcond {{ (ret == 0) || (ret == 1) }};

  out' <- crucible_fresh_var "out" (llvm_array out_len i8);
  crucible_conditional_points_to {{ ret == 1 }} out_ptr (crucible_term out');

  // TODO: With padding this out_len_ptr value may not be known, just that it
  // must be less than or equal to out_len
  //crucible_points_to out_len_ptr (crucible_term {{ `out_len : [64] }});

  crucible_return (crucible_term {{ ret : [32] }});
};


let EVP_PKEY_encrypt_spec out_len in_len modulus_bytes pad_mode oaep_size = do {
  // TODO: Do I have to initialize this global?
  //crucible_alloc_global "g_thread_local_init_once";
  k <- crucible_fresh_cryptol_var "k" {| [SHA256_DIGEST_LENGTH][8] |};
  crucible_ghost_value oaep_random_out k;
  
  ctx_ptr <- crucible_alloc (llvm_struct "struct.evp_pkey_ctx_st");
  pmeth_ptr <- crucible_alloc (llvm_struct "struct.evp_pkey_method_st");
  points_to_evp_pkey_method_st pmeth_ptr;
  pkey_ptr <- crucible_alloc (llvm_struct "struct.evp_pkey_st");
  rsa_ptr <- crucible_alloc (llvm_struct "struct.rsa_st");
  meth_ptr <- crucible_alloc (llvm_struct "struct.rsa_meth_st");
  points_to_rsa_meth_st meth_ptr;
  n_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  let modulus_words = eval_int {{ ((`modulus_bytes + 7) / 8) : [64]}};
  (n_d, n_d_ptr) <- ptr_to_fresh "n_d" (llvm_array modulus_words i64);
  points_to_bignum_st_same n_ptr n_d_ptr modulus_words;
  // `n_d` must have a nonzero value in byte (modulus_bytes - 1) to be considered
  // `modulus_bytes` long.
  // TODO: Handle case where modulus_bytes is not a multiple of 8
  // TODO: Test and update comment
  crucible_precond {{ (n_d ! 0) >= (2^^63) }};
  // `n_d` must be odd
  // TODO: I think this somehow breaks when OPENSSL_PUT_ERROR is properly
  // defined?
  crucible_precond {{ ((n_d @ 0) && 1) == 1 }};
  //crucible_precond {{ ((split`{each=8} (join n_d)) @ (`modulus_bytes - 1)) > 0 }};
  // TODO: If `modulus_bytes` is not a multiple of the word
  // size (8), then `n_d` must have all bytes above `modulus_bytes` zeroed
  // out.
  e_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  (e_d, e_d_ptr) <- ptr_to_fresh "e_d" i64;
  // e_d must be 33 bits or fewer wide
  crucible_precond {{ e_d <= (2 ^^ 33 - 1) }};
  points_to_bignum_st_same e_ptr e_d_ptr 1;
  // TODO: I just passed in nullptr for d_ptr here.  I think that should be
  // fine, but if this proof breaks, that's one place to look
  points_to_rsa_st rsa_ptr meth_ptr n_ptr e_ptr crucible_null 0 crucible_null crucible_null crucible_null crucible_null crucible_null;
  points_to_evp_pkey_st pkey_ptr rsa_ptr;
  // TODO: data_ptr actully points to an RSA_PKEY_CTX struct.  Be *very
  // careful* with getting the contents of this right.
  data_ptr <- crucible_alloc (llvm_array RSA_PKEY_CTX_WORDS i64);
  md_ptr <- crucible_alloc_readonly (llvm_struct "struct.env_md_st");
  points_to_env_md_st md_ptr;
  (oaep_label, oaep_label_ptr) <- ptr_to_fresh "oaep_label" (llvm_array oaep_size i8);
  points_to_rsa_pkey_ctx data_ptr pad_mode md_ptr oaep_label_ptr oaep_size;
  points_to_evp_pkey_ctx_st ctx_ptr pmeth_ptr pkey_ptr EVP_PKEY_OP_ENCRYPT data_ptr;

  out_ptr <- crucible_alloc (llvm_array out_len i8);

  out_len_ptr <- crucible_alloc i64;
  crucible_points_to out_len_ptr (crucible_term {{ `out_len : [64] }});

  (input, in_ptr) <- ptr_to_fresh_readonly "input" (llvm_array in_len i8);
  // TODO: This effectively makes input < n_d (whcih is required), but it does
  // so in a hacky way.  This precondition should directly reference n_d.
  // The interface is dumb so `input` is a big endian number but `n_d` is
  // little endian...
  crucible_precond {{ (input @ 0) == 0 }};

  crucible_execute_func
    [ ctx_ptr
    , out_ptr
    , out_len_ptr
    , in_ptr
    , crucible_term {{ `in_len : [64] }}
    ];

  out' <- crucible_fresh_var "out" (llvm_array out_len i8);
  crucible_points_to out_ptr (crucible_term out');

  crucible_points_to out_len_ptr (crucible_term {{ `out_len : [64] }});

  crucible_return (crucible_term {{ 1 : [32] }});
};

let {{ ia32cap = [0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff] : [4][32] }};
let EVP_PKEY_decrypt_spec out_len in_len modulus_bytes d_words rsa_flags prime_words pad_mode oaep_size = do {
  // TODO: Do I have to initialize this global?
  //crucible_alloc_global "g_thread_local_init_once";
  // TODO: Might want postcondition that OPENSSL_ia32cap_P is unchanged too
  global_alloc_init "OPENSSL_ia32cap_P" {{ ia32cap }};
  
  ctx_ptr <- crucible_alloc (llvm_struct "struct.evp_pkey_ctx_st");
  pmeth_ptr <- crucible_alloc (llvm_struct "struct.evp_pkey_method_st");
  points_to_evp_pkey_method_st pmeth_ptr;
  pkey_ptr <- crucible_alloc (llvm_struct "struct.evp_pkey_st");
  rsa_ptr <- crucible_alloc (llvm_struct "struct.rsa_st");
  meth_ptr <- crucible_alloc (llvm_struct "struct.rsa_meth_st");
  points_to_rsa_meth_st meth_ptr;
  n_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  let modulus_words = eval_int {{ ((`modulus_bytes + 7) / 8) : [64]}};
  (n_d, n_d_ptr) <- ptr_to_fresh "n_d" (llvm_array modulus_words i64);
  points_to_bignum_st_same n_ptr n_d_ptr modulus_words;
  // `n_d` must have a nonzero value in byte (modulus_bytes - 1) to be considered
  // `modulus_bytes` long.
  // TODO: Handle case where modulus_bytes is not a multiple of 8
  crucible_precond {{ (n_d ! 0) >= (2^^63) }};
  // `n_d` must be odd
  // TODO: I think this somehow breaks when OPENSSL_PUT_ERROR is properly
  // defined?
  crucible_precond {{ ((n_d @ 0) && 1) == 1 }};
  //crucible_precond {{ ((split`{each=8} (join n_d)) @ (`modulus_bytes - 1)) > 0 }};
  // TODO: If `modulus_bytes` is not a multiple of the word
  // size (8), then `n_d` must have all bytes above `modulus_bytes` zeroed
  // out.

  e_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  (e_d, e_d_ptr) <- ptr_to_fresh "e_d" i64;
  // e_d must be 33 bits or fewer wide
  crucible_precond {{ e_d <= (2 ^^ 33 - 1) }};
  points_to_bignum_st_same e_ptr e_d_ptr 1;

  d_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  (d_d, d_d_ptr) <- ptr_to_fresh "d_d" (llvm_array d_words i64);
  points_to_bignum_st_same d_ptr d_d_ptr d_words;

  if eval_bool {{ `prime_words == 0 }} then do {
    // No CRM.  Leave p+q (and related fields) null
    points_to_rsa_st rsa_ptr
                     meth_ptr
                     n_ptr
                     e_ptr
                     d_ptr
                     rsa_flags
                     crucible_null
                     crucible_null
                     crucible_null
                     crucible_null
                     crucible_null;
  } else do {
    // CRM case
    // Fields for p+q case
    // TODO: guard behind prime_words being non-zero.  Otherwise make these null
    p_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
    (p_d, p_d_ptr) <- ptr_to_fresh "p_d" (llvm_array prime_words i64);
    crucible_precond {{ ((p_d @ 0) && 1) == 1 }};  // p must be odd
    points_to_bignum_st_same p_ptr p_d_ptr prime_words;
    q_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
    (q_d, q_d_ptr) <- ptr_to_fresh "q_d" (llvm_array prime_words i64);
    crucible_precond {{ ((q_d @ 0) && 1) == 1 }};  // q must be odd
    points_to_bignum_st_same q_ptr q_d_ptr prime_words;
    dmp1_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
    (dmp1_d, dmp1_d_ptr) <- ptr_to_fresh "dmp1_d" (llvm_array prime_words i64);
    points_to_bignum_st_same dmp1_ptr dmp1_d_ptr prime_words;
    dmq1_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
    (dmq1_d, dmq1_d_ptr) <- ptr_to_fresh "dmq1_d" (llvm_array prime_words i64);
    points_to_bignum_st_same dmq1_ptr dmq1_d_ptr prime_words;
    iqmp_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
    (iqmp_d, iqmp_d_ptr) <- ptr_to_fresh "iqmp_d" (llvm_array prime_words i64);
    points_to_bignum_st_same iqmp_ptr iqmp_d_ptr prime_words;
    points_to_rsa_st rsa_ptr
                     meth_ptr
                     n_ptr
                     e_ptr
                     d_ptr
                     rsa_flags
                     p_ptr
                     q_ptr
                     dmp1_ptr
                     dmq1_ptr
                     iqmp_ptr;
  };
  points_to_evp_pkey_st pkey_ptr rsa_ptr;
  // TODO: data_ptr actully points to an RSA_PKEY_CTX struct.  Be *very
  // careful* with getting the contents of this right.
  data_ptr <- crucible_alloc (llvm_array RSA_PKEY_CTX_WORDS i64);
  md_ptr <- crucible_alloc_readonly (llvm_struct "struct.env_md_st");
  points_to_env_md_st md_ptr;
  (oaep_label, oaep_label_ptr) <- ptr_to_fresh "oaep_label" (llvm_array oaep_size i8);
  points_to_rsa_pkey_ctx data_ptr pad_mode md_ptr oaep_label_ptr oaep_size;
  points_to_evp_pkey_ctx_st ctx_ptr pmeth_ptr pkey_ptr EVP_PKEY_OP_DECRYPT data_ptr;

  (out, out_ptr) <- ptr_to_fresh "out" (llvm_array out_len i8);

  out_len_ptr <- crucible_alloc i64;
  crucible_points_to out_len_ptr (crucible_term {{ `out_len : [64] }});

  (input, in_ptr) <- ptr_to_fresh_readonly "input" (llvm_array in_len i8);
  // TODO: This effectively makes input < n_d (whcih is required), but it does
  // so in a hacky way.  This precondition should directly reference n_d.
  // The interface is dumb so `input` is a big endian number but `n_d` is
  // little endian...
  crucible_precond {{ (input @ 0) == 0 }};

  // TODO: Fill these params in properly
  crucible_execute_func
    [ ctx_ptr
    , out_ptr
    , out_len_ptr
    , in_ptr
    , crucible_term {{ `in_len : [64] }}
    ];

  ret <- crucible_fresh_var "ret" i32;

  out' <- crucible_fresh_var "out" (llvm_array out_len i8);
  crucible_conditional_points_to {{ ret == 1 }} out_ptr (crucible_term out');

  // TODO: With padding this out_len_ptr value may not be known, just that it
  // must be less than or equal to out_len
  //crucible_points_to out_len_ptr (crucible_term {{ `out_len : [64] }});

  crucible_return (crucible_term {{ ret : [32] }});
};


///////////////////////////////////////////////////////////////////////////////
// Assumptions
///////////////////////////////////////////////////////////////////////////////

BN_BLINDING_convert_ov <- crucible_llvm_unsafe_assume_spec
  m
  "BN_BLINDING_convert"
  // TODO: Check the output size
  (BN_BLINDING_convert_spec 9);

  // TODO: Check RAND_bytes size
RAND_bytes_ov <- crucible_llvm_unsafe_assume_spec
  m
  "RAND_bytes"
  (RAND_bytes_spec 32);

EVP_DigestFinal_ex_ov <- crucible_llvm_unsafe_assume_spec
  m
  "EVP_DigestFinal_ex"
  (EVP_DigestFinal_ex_spec 0);

mod_exp_ov <- crucible_llvm_unsafe_assume_spec
  m
  "mod_exp"
  (mod_exp_spec 9);

constant_time_eq_w_ov <- crucible_llvm_unsafe_assume_spec
  m
  "constant_time_eq_w"
  (constant_time_eq_w_spec);

// TODO: Just run the proof once its fixed
EVP_Digest_ov <- crucible_llvm_unsafe_assume_spec
  m
  "EVP_Digest"
  (EVP_Digest_spec 1);



///////////////////////////////////////////////////////////////////////////////
// Proofs
///////////////////////////////////////////////////////////////////////////////


// TODO: Probably don't need all of these overrides
RSA_padding_add_PKCS1_OAEP_mgf1_ov <- crucible_llvm_verify
  m
  "RSA_padding_add_PKCS1_OAEP_mgf1"
  (concat
   OPENSSL_free_nonnull_ovs
   (concat
    OPENSSL_malloc_concrete_ovs
    [value_barrier_w_ov,
     OPENSSL_free_null_ov,
     OPENSSL_malloc_ov,
     OPENSSL_cleanse_ov,
     CRYPTO_MUTEX_lock_read_ov,
     CRYPTO_MUTEX_unlock_read_ov,
     CRYPTO_MUTEX_lock_write_ov,
     CRYPTO_MUTEX_unlock_write_ov,
     RAND_bytes_ov,
     OPENSSL_realloc_null_concrete_ov,
     OPENSSL_realloc_nonnull_ov,
     sha256_block_data_order_spec]))
  true
  (RSA_padding_add_PKCS1_OAEP_mgf1_spec 72 6 1)
  do {
    //(simplify basic_ss);
    //(print_goal);
    (goal_eval_unint ["processBlock_Common"]);
    (print_goal);
    (w4_unint_yices ["processBlock_Common"]);
  };

/*
// Padding mode: RSA_PKCS1_OAEP_PADDING
crucible_llvm_verify m "EVP_PKEY_encrypt"
  (concat
   OPENSSL_free_nonnull_ovs
   (concat
    OPENSSL_malloc_concrete_ovs
    [value_barrier_w_ov,
     OPENSSL_free_null_ov,
     OPENSSL_malloc_ov,
     CRYPTO_MUTEX_lock_read_ov,
     CRYPTO_MUTEX_unlock_read_ov,
     CRYPTO_MUTEX_lock_write_ov,
     CRYPTO_MUTEX_unlock_write_ov,
     OPENSSL_realloc_null_concrete_ov,
     OPENSSL_realloc_nonnull_ov,
     BN_mod_exp_mont_9_ov,
     BN_bn2bin_padded_same_size_9_ov,
     bn_mont_n0_9_ov,
     OPENSSL_cleanse_ov,
     BN_div_9_ov,
     BN_bin2bn_9_ov,
     RSA_padding_add_PKCS1_OAEP_mgf1_ov]))
  true
  (EVP_PKEY_encrypt_spec 72 6 72 RSA_PKCS1_OAEP_PADDING 1)
  do {
    //(simplify basic_ss);
    //(print_goal);
    (w4_unint_yices ["bn_mont_n0"]);
  };
  */

/*
// TODO: Probably don't need all of these overrides (ex. CRYPTO_MUTEX*)
// TODO: Adding EVP_Digest_ov might speed this up a tad bit more?
RSA_padding_check_PKCS1_OAEP_mgf1_ov <- crucible_llvm_verify
  m
  "RSA_padding_check_PKCS1_OAEP_mgf1"
  (concat
   OPENSSL_free_nonnull_ovs
   (concat
    OPENSSL_malloc_concrete_ovs
    [value_barrier_w_ov,
     OPENSSL_free_null_ov,
     OPENSSL_malloc_ov,
     CRYPTO_MUTEX_lock_read_ov,
     CRYPTO_MUTEX_unlock_read_ov,
     CRYPTO_MUTEX_lock_write_ov,
     CRYPTO_MUTEX_unlock_write_ov,
     OPENSSL_realloc_null_concrete_ov,
     OPENSSL_realloc_nonnull_ov,
     sha256_block_data_order_spec,
     constant_time_eq_w_ov,
     constant_time_select_w_true_ov,
     constant_time_select_w_false_ov,
     ERR_put_error_ov,
     EVP_DigestFinal_ex_ov]))
  true
  (RSA_padding_check_PKCS1_OAEP_mgf1_spec 72 72 72 1)
  do {
    //(simplify basic_ss);
    //(print_goal);
    (w4_unint_yices ["bn_mont_n0"]);
  };

// -CRM -blinding
crucible_llvm_verify m "EVP_PKEY_decrypt"
  (concat
   OPENSSL_free_nonnull_ovs
   (concat
    OPENSSL_malloc_concrete_ovs
    [value_barrier_w_ov,
     OPENSSL_free_null_ov,
     OPENSSL_malloc_ov,
     CRYPTO_MUTEX_lock_read_ov,
     CRYPTO_MUTEX_unlock_read_ov,
     CRYPTO_MUTEX_lock_write_ov,
     CRYPTO_MUTEX_unlock_write_ov,
     OPENSSL_realloc_null_concrete_ov,
     OPENSSL_realloc_nonnull_ov,
     BN_bn2bin_padded_same_size_9_ov,
     BN_mod_exp_mont_consttime_9_ov,
     BN_mod_exp_mont_9_ov,
     BN_equal_consttime_ov,
     bn_mont_n0_9_ov,
     RSA_padding_check_PKCS1_OAEP_mgf1_ov,
     BN_div_9_ov]))
  true
  // TODO: What's a reasonable size for d?
  (EVP_PKEY_decrypt_spec 72 72 72 8 RSA_FLAG_NO_BLINDING 0 RSA_PKCS1_OAEP_PADDING 1)
  do {
    //(simplify basic_ss);
    //(print_goal);
    (w4_unint_yices ["bn_mont_n0"]);
  };

// -CRM +blinding
crucible_llvm_verify m "EVP_PKEY_decrypt"
  (concat
   OPENSSL_free_nonnull_ovs
   (concat
    OPENSSL_malloc_concrete_ovs
    [value_barrier_w_ov,
     OPENSSL_free_null_ov,
     OPENSSL_malloc_ov,
     CRYPTO_MUTEX_lock_read_ov,
     CRYPTO_MUTEX_unlock_read_ov,
     CRYPTO_MUTEX_lock_write_ov,
     CRYPTO_MUTEX_unlock_write_ov,
     OPENSSL_realloc_null_concrete_ov,
     OPENSSL_realloc_nonnull_ov,
     BN_bn2bin_padded_same_size_9_ov,
     BN_mod_exp_mont_consttime_9_ov,
     BN_mod_exp_mont_9_ov,
     bn_mont_n0_9_ov,
     CRYPTO_get_fork_generation_ov,
     BN_BLINDING_convert_ov,
     BN_equal_consttime_ov,
     BN_mod_mul_montgomery_9_ov,
     RSA_padding_check_PKCS1_OAEP_mgf1_ov,
     BN_div_9_ov]))
  true
  (EVP_PKEY_decrypt_spec 72 72 72 8 0 0 RSA_PKCS1_OAEP_PADDING 1)
  do {
    //(simplify basic_ss);
    //(print_goal);
    (w4_unint_yices ["bn_mont_n0"]);
  };

// +CRM -blinding
crucible_llvm_verify m "EVP_PKEY_decrypt"
  (concat
   OPENSSL_free_nonnull_ovs
   (concat
    OPENSSL_malloc_concrete_ovs
    [value_barrier_w_ov,
     OPENSSL_free_null_ov,
     OPENSSL_malloc_ov,
     CRYPTO_MUTEX_lock_read_ov,
     CRYPTO_MUTEX_unlock_read_ov,
     CRYPTO_MUTEX_lock_write_ov,
     CRYPTO_MUTEX_unlock_write_ov,
     OPENSSL_realloc_null_concrete_ov,
     OPENSSL_realloc_nonnull_ov,
     BN_bn2bin_padded_same_size_9_ov,
     BN_mod_exp_mont_consttime_1_ov,
     RSA_padding_check_PKCS1_OAEP_mgf1_ov,
     BN_mod_exp_mont_9_ov,
     BN_equal_consttime_ov,
     bn_mont_n0_1_ov,
     bn_mont_n0_9_ov,
     bn_mod_exp_base_2_consttime_ov,
     BN_mod_mul_montgomery_nonoverlap_1_ov,
     mod_exp_ov,
     BN_mod_mul_montgomery_1_ov,  // TODO: Don't use this as is with blinding
     BN_div_9_ov]))
  true
  (EVP_PKEY_decrypt_spec 72 72 72 8 RSA_FLAG_NO_BLINDING 1 RSA_PKCS1_OAEP_PADDING 1)
  do {
    //(simplify basic_ss);
    //(print_goal);
    (w4_unint_yices ["bn_mont_n0"]);
  };

// +CRM +blinding
crucible_llvm_verify m "EVP_PKEY_decrypt"
  (concat
   OPENSSL_free_nonnull_ovs
   (concat
    OPENSSL_malloc_concrete_ovs
    [value_barrier_w_ov,
     OPENSSL_free_null_ov,
     OPENSSL_malloc_ov,
     CRYPTO_MUTEX_lock_read_ov,
     CRYPTO_MUTEX_unlock_read_ov,
     CRYPTO_MUTEX_lock_write_ov,
     CRYPTO_MUTEX_unlock_write_ov,
     OPENSSL_realloc_null_concrete_ov,
     OPENSSL_realloc_nonnull_ov,
     BN_bn2bin_padded_same_size_9_ov,
     BN_mod_exp_mont_consttime_1_ov,
     BN_mod_exp_mont_9_ov,
     CRYPTO_get_fork_generation_ov,
     BN_BLINDING_convert_ov,
     BN_equal_consttime_ov,
     bn_mont_n0_1_ov,
     bn_mont_n0_9_ov,
     bn_mod_exp_base_2_consttime_ov,
     BN_mod_mul_montgomery_nonoverlap_1_ov,
     mod_exp_ov,
     RSA_padding_check_PKCS1_OAEP_mgf1_ov,
     BN_mod_mul_montgomery_9_ov,
     BN_mod_mul_montgomery_1_ov,
     BN_div_9_ov]))
  true
  (EVP_PKEY_decrypt_spec 72 72 72 8 0 1 RSA_PKCS1_OAEP_PADDING 1)
  do {
    //(simplify basic_ss);
    //(print_goal);
    (w4_unint_yices ["bn_mont_n0"]);
  };
*/
