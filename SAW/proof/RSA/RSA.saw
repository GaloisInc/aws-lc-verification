// TODO: Copyright notice
// TODO: Split into multiple files

enable_experimental;

m <- llvm_load_module "../../build/llvm/crypto/crypto_test.bc";

include "../common/helpers.saw";

let EVP_PKEY_OP_ENCRYPT = 64;
let RSA_NO_PADDING = 3;
//let RSA_PKEY_CTX_SIZE = eval_int {{ (4 + 8 + 4 + 8 + 8 + 4 + 8 + 8 + 8) : [64] }};
//let RSA_PKEY_CTX_SIZE = eval_int {{ (8 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 8) : [64] }};
// RSA_PKEY_CTX is a mix of 9 ints and pointers.  However, no two ints appear
// consecutively in the struct, so the compiler must pad them out with an extra
// 32 bits on the end.  This combined with little-endian encoding means we can
// abstract over the struct as an array of 9 64-bit integers.
let RSA_PKEY_CTX_WORDS = 9;
let PAD_MODE_IDX = 2;

// TODO: Re-enable asserts on montgomery_inv.c:120 and 160 (disabled because SAW is slow
// to reason about it)

// TODO: Put this in a common file with the SHA memory specs?
let OPENSSL_malloc_sym_spec = do {
  size <- crucible_fresh_var "size" i64;
  crucible_execute_func [crucible_term size];
  ptr <- crucible_symbolic_alloc false 16 size;
  crucible_return ptr;
};

let OPENSSL_malloc_spec size = do {
  crucible_execute_func [crucible_term {{ `size : [64] }}];
  ptr <- crucible_alloc_aligned 128 (llvm_array size (llvm_int 8));
  crucible_return ptr;
};

let OPENSSL_free_nonnull_spec size = do {
  ptr <- crucible_alloc (llvm_array size (llvm_int 8));
  crucible_execute_func [ptr];
};


let OPENSSL_free_null_spec = do {
  crucible_execute_func [crucible_null];
};

let CRYPTO_MUTEX_lock_spec = do {
  lock_ptr <- crucible_alloc (llvm_struct "union.crypto_mutex_st");
  crucible_execute_func [lock_ptr];
};

OPENSSL_free_null_ov <- crucible_llvm_unsafe_assume_spec
  m
  "OPENSSL_free"
  OPENSSL_free_null_spec;

CRYPTO_MUTEX_lock_read_ov <- crucible_llvm_unsafe_assume_spec
  m
  "CRYPTO_MUTEX_lock_read"
  CRYPTO_MUTEX_lock_spec;

CRYPTO_MUTEX_unlock_read_ov <- crucible_llvm_unsafe_assume_spec
  m
  "CRYPTO_MUTEX_unlock_read"
  CRYPTO_MUTEX_lock_spec;

CRYPTO_MUTEX_lock_write_ov <- crucible_llvm_unsafe_assume_spec
  m
  "CRYPTO_MUTEX_lock_write"
  CRYPTO_MUTEX_lock_spec;

CRYPTO_MUTEX_unlock_write_ov <- crucible_llvm_unsafe_assume_spec
  m
  "CRYPTO_MUTEX_unlock_write"
  CRYPTO_MUTEX_lock_spec;


// Assume `OPENSSL_malloc` satisfies `OPENSSL_malloc_spec`
// TODO: I think the 48 byte malloc applies to rsa_impl.c:284 but it's not
// clear to me why rsa_size would have to be 48 bytes.  It seems like it could
// be any value between 0 and the modulus size in bytes (64 with the current
// setting).
/*
OPENSSL_malloc_ov_48 <- crucible_llvm_unsafe_assume_spec
  m
  "OPENSSL_malloc"
  (OPENSSL_malloc_spec 48);
// TODO: Where do these mallocs come from?
OPENSSL_malloc_ov_256 <- crucible_llvm_unsafe_assume_spec
  m
  "OPENSSL_malloc"
  (OPENSSL_malloc_spec 256);
OPENSSL_malloc_ov_40 <- crucible_llvm_unsafe_assume_spec
  m
  "OPENSSL_malloc"
  (OPENSSL_malloc_spec 40);
  */

/*
malloc_nums <- for (eval_list {{ [0 .. 256 : [64]] }})
  (\x -> (return (eval_int x)) : (TopLevel Int));
  */

// TODO: Where are all of these allocs comming from?  Run with --sim-verbose=3
// for stack traces on them and double check they're sensible.
let malloc_nums = [24, 32, 40, 48, 256];

OPENSSL_malloc_ovs <- for malloc_nums
  (\x -> crucible_llvm_unsafe_assume_spec m "OPENSSL_malloc" (OPENSSL_malloc_spec x));

OPENSSL_malloc_sym_ov <- crucible_llvm_unsafe_assume_spec
  m
  "OPENSSL_malloc"
  OPENSSL_malloc_sym_spec;

// TODO: Remove the 24 once you get the first thing to free here
let free_nums = [24];
OPENSSL_free_nonnull_ovs <- for free_nums
  (\x -> crucible_llvm_unsafe_assume_spec m
         "OPENSSL_free"
         (OPENSSL_free_nonnull_spec x));

// value_barrier_w just returns its input (it exists to prevent the compiler
// from unding constant-time code)
let value_barrier_w_spec = do {
  a <- crucible_fresh_var "a" i64;
  crucible_execute_func [(crucible_term a)];
  crucible_return (crucible_term a);
};

value_barrier_w_ov <- crucible_llvm_unsafe_assume_spec
  m
  "value_barrier_w"
  value_barrier_w_spec;

let points_to_evp_pkey_ctx_st ptr pmeth_ptr pkey_ptr operation data_ptr = do {
  crucible_points_to (crucible_field ptr "pmeth") pmeth_ptr;
  crucible_points_to (crucible_field ptr "pkey") pkey_ptr;
  crucible_points_to (crucible_field ptr "operation")
                     (crucible_term {{ `operation : [32] }});
  crucible_points_to (crucible_field ptr "data") data_ptr;
};

let points_to_evp_pkey_method_st ptr = do {
  crucible_points_to (crucible_field ptr "encrypt")
                     (crucible_global "pkey_rsa_encrypt");
};

let points_to_evp_pkey_st ptr rsa_ptr = do {
  crucible_points_to (crucible_field ptr "pkey") rsa_ptr;
  crucible_points_to (crucible_field ptr "ameth")
                     (crucible_global "rsa_asn1_meth");
};

// TODO: This implements the default RSA_METHOD, which is all NULL.  Do we want
// to support non-default RSA_METHOD structs?
let points_to_rsa_meth_st ptr = do {
  crucible_points_to (crucible_field ptr "size") crucible_null;
};

let points_to_rsa_st ptr meth_ptr n_ptr e_ptr = do {
  crucible_points_to (crucible_field ptr "meth") meth_ptr;
  crucible_points_to (crucible_field ptr "n") n_ptr;
  crucible_points_to (crucible_field ptr "e") e_ptr;
  // TODO: Should this field be null?  mont_n is a cache, and setting it to
  // forces the encrypt function to initialize the cache, which seems right
  // here.  Is there a reason it wouldn't be null?
  crucible_points_to (crucible_field ptr "mont_n") crucible_null;
};

let points_to_bignum_st ptr d_ptr width = do {
  crucible_points_to (crucible_field ptr "d") d_ptr;
  crucible_points_to (crucible_field ptr "width")
                     (crucible_term {{ `width : [32] }});
  crucible_points_to (crucible_field ptr "neg")
                     (crucible_term {{ 0 : [32] }});
};

let points_to_rsa_pkey_ctx ptr = do {
  // `pad_mode` is technically a 32 bit integer, but the compiler must pad the
  // space to 64 bits as the following element in the struct is a pointer.
  // We can treat this int like a 64-bit value as little-endian encoding
  // ensures the low order bytes end up at the lower address and fit in the 32
  // bits dedicated to the `pad_mode` field.
  crucible_points_to (crucible_elem ptr PAD_MODE_IDX)
                     (crucible_term {{ `RSA_NO_PADDING : [64] }});
};

/*
let EVP_PKEY_init = do {
  pkey <- crucible_alloc 
}
*/

/*
let rsa_st_init = do {

}
*/

// TODO: Verify this still works after reverting change to OPENSSL_PUT_ERROR
// (Initially changed because it requires some pthread functions and is
// orthogonal to what we want to prove).
// Potential problems:
//  * p_rsa.c:318: rsa->n might be underconstrained and trigger this
//    OPENSSL_PUT_ERROR.  Just need to properly set n to fix this.
// TODO: out_len must be >= modulus_bytes
let EVP_PKEY_encrypt_spec out_len in_len modulus_bytes = do {
  // TODO: Do I have to initialize this global?
  //crucible_alloc_global "g_thread_local_init_once";
  
  ctx_ptr <- crucible_alloc (llvm_struct "struct.evp_pkey_ctx_st");
  pmeth_ptr <- crucible_alloc (llvm_struct "struct.evp_pkey_method_st");
  points_to_evp_pkey_method_st pmeth_ptr;
  pkey_ptr <- crucible_alloc (llvm_struct "struct.evp_pkey_st");
  rsa_ptr <- crucible_alloc (llvm_struct "struct.rsa_st");
  meth_ptr <- crucible_alloc (llvm_struct "struct.rsa_meth_st");
  points_to_rsa_meth_st meth_ptr;
  n_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  let modulus_words = eval_int {{ ((`modulus_bytes + (`modulus_bytes % 8)) / 8) : [64]}};
  (n_d, n_d_ptr) <- ptr_to_fresh "n_d" (llvm_array modulus_words i64);
  points_to_bignum_st n_ptr n_d_ptr modulus_words;
  // `n_d` must have a nonzero value in byte (modulus_bytes - 1) to be considered
  // `modulus_bytes` long.
  // TODO: Handle case where modulus_bytes is not a multiple of 8
  crucible_precond {{ (n_d ! 0) >= (2^^56) }};
  // `n_d` must be odd
  // TODO: I think this somehow breaks when OPENSSL_PUT_ERROR is properly
  // defined?
  crucible_precond {{ ((n_d @ 0) && 1) == 1 }};
  //crucible_precond {{ ((split`{each=8} (join n_d)) @ (`modulus_bytes - 1)) > 0 }};
  // TODO: If `modulus_bytes` is not a multiple of the word
  // size (8), then `n_d` must have all bytes above `modulus_bytes` zeroed
  // out.
  e_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  (e_d, e_d_ptr) <- ptr_to_fresh "e_d" i64;
  // e_d must be 33 bits or fewer wide
  crucible_precond {{ e_d <= (2 ^^ 33 - 1) }};
  points_to_bignum_st e_ptr e_d_ptr 1;
  points_to_rsa_st rsa_ptr meth_ptr n_ptr e_ptr;
  points_to_evp_pkey_st pkey_ptr rsa_ptr;
  // TODO: data_ptr actully points to an RSA_PKEY_CTX struct.  Be *very
  // careful* with getting the contents of this right.
  data_ptr <- crucible_alloc (llvm_array RSA_PKEY_CTX_WORDS i64);
  points_to_rsa_pkey_ctx data_ptr;
  points_to_evp_pkey_ctx_st ctx_ptr pmeth_ptr pkey_ptr EVP_PKEY_OP_ENCRYPT data_ptr;

  out_ptr <- crucible_alloc (llvm_array out_len i8);

  out_len_ptr <- crucible_alloc i64;
  crucible_points_to out_len_ptr (crucible_term {{ `out_len : [64] }});

  (input, in_ptr) <- ptr_to_fresh_readonly "input" (llvm_array in_len i8);

  // TODO: Fill these params in properly
  crucible_execute_func
    [ ctx_ptr
    , out_ptr
    , out_len_ptr
    , in_ptr
    , crucible_term {{ `in_len : [64] }}
    ];

  crucible_return (crucible_term {{ 1 : [32] }});
};

crucible_llvm_verify m "EVP_PKEY_encrypt"
  (concat OPENSSL_malloc_ovs
          [value_barrier_w_ov,
           OPENSSL_free_null_ov,
           OPENSSL_malloc_sym_ov,
           CRYPTO_MUTEX_lock_read_ov,
           CRYPTO_MUTEX_unlock_read_ov,
           CRYPTO_MUTEX_lock_write_ov,
           CRYPTO_MUTEX_unlock_write_ov ])
  //(concat [value_barrier_w_ov] OPENSSL_malloc_ovs)
  true
  (EVP_PKEY_encrypt_spec 64 64 64)
  do {
    (w4_unint_yices []);
  };
