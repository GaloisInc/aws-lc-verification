/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
*/


import "../../../cryptol-specs/Common/EC/EC_P384.cry";


include "../ECDSA/goal-rewrites.saw";


/*
 * Verification parameters.
 */
let EVP_PKEY_OP_DERIVE = eval_int {{ (1 << 8) : [64] }};


m <- llvm_load_module "../../build/llvm/crypto/crypto_test.bc";


include "../common/helpers.saw";
include "../common/internal.saw";
include "../common/memory.saw";
include "../BN/BN.saw";
include "../EC/EC.saw";


// Specification of the EVP function
let EVP_PKEY_derive_spec = do {
  ctx_ptr <- crucible_alloc_readonly (llvm_struct "struct.evp_pkey_ctx_st");
  ec_group_ptr <- pointer_to_fresh_ec_group_st;
  pkey_ptr <- crucible_alloc_readonly (llvm_struct "struct.evp_pkey_st");
  (ec_key_ptr, _pub_key, priv_key) <- pointer_to_fresh_ec_key_st ec_group_ptr true;
  points_to_evp_pkey_st pkey_ptr ec_key_ptr;
  peerkey_ptr <- crucible_alloc_readonly (llvm_struct "struct.evp_pkey_st");
  (peer_ec_key_ptr, peer_pub_key, _peer_priv_key) <- pointer_to_fresh_ec_key_st ec_group_ptr false;
  points_to_evp_pkey_st peerkey_ptr peer_ec_key_ptr;
  points_to_evp_pkey_ctx_st ctx_ptr pkey_ptr peerkey_ptr EVP_PKEY_OP_DERIVE crucible_null;

  key_ptr <- crucible_alloc (llvm_array ec_bytes i8);
  out_key_len_ptr <- crucible_alloc i64;
  crucible_points_to out_key_len_ptr (crucible_term {{ `ec_bytes : [64] }});

  crucible_execute_func [ctx_ptr, key_ptr, out_key_len_ptr];

  crucible_points_to key_ptr (crucible_term {{ split`{each=8} (fieldElementToBV (ECDH_derive (scalarFromBV priv_key) (fromJacobian (jacobianFromMontBV peer_pub_key)))) }});

  crucible_points_to out_key_len_ptr (crucible_term {{ `ec_bytes : [64] }});

  crucible_return (crucible_term {{ 1 : [32] }});
};


////////////////////////////////////////////////////////////////////////////////
// Proof commands

jacobian_affine_2_thm <- prove_print
  (do {
    assume_unsat;
  })
  (rewrite (cryptol_ss ()) {{ \d Q -> fromJacobian { x = ((ec_point_jacobian_scalar_mul d Q).x % `P384_p), y = ((ec_point_jacobian_scalar_mul d Q).y % `P384_p), z = ((ec_point_jacobian_scalar_mul d Q).z % `P384_p) } == ec_point_affine_scalar_mul d (fromJacobian Q) }});

llvm_verify m "EVP_PKEY_derive"
  [ ec_point_mul_scalar_ov
  , ec_get_x_coordinate_as_bytes_ov
  ]
  true
  EVP_PKEY_derive_spec
  (do {
    unfolding ["jacobianToMontBV", "jacobianFromMontBV", "jacobianToMont", "jacobianFromMont", "jacobianToBV", "jacobianFromBV"];
    simplify (cryptol_ss ());
    simplify (addsimp fieldElementBV_thm empty_ss);
    simplify (addsimps mont_thms empty_ss);
    simplify (addsimp jacobian_affine_2_thm empty_ss);
    goal_eval_unint ["ec_point_affine_scalar_mul", "fromJacobian"];
    w4_unint_z3 ["ec_point_affine_scalar_mul", "fromJacobian"];
  });

